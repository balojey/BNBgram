var Wo=Object.defineProperty;var Fo=(o,e,t)=>e in o?Wo(o,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):o[e]=t;var ce=(o,e,t)=>(Fo(o,typeof e!="symbol"?e+"":e,t),t);import{w as ds,H as Do,a as Br,u as Mo,i as vr,b as Pr,c as Tr,t as qo,d as Ho,e as $o,f as Vo,F as hs,h as Bn,v as jo,j as Go,p as Yo,k as Nt,l as Ze,m as vn,n as Lr,o as Jo,q as Xo,r as Cr,s as Or,x as Qe,y as Zo,z as Qo,A as qe,B as fs,C as ei,D as ti,E as Ve,G as T,g as ni,I as ps,J as pe,K as zr,L as Ur,M as Jn}from"./index-BhBC04XT.js";const Zt=BigInt(2**32-1),$n=BigInt(32);function ys(o,e=!1){return e?{h:Number(o&Zt),l:Number(o>>$n&Zt)}:{h:Number(o>>$n&Zt)|0,l:Number(o&Zt)|0}}function gs(o,e=!1){let t=new Uint32Array(o.length),n=new Uint32Array(o.length);for(let r=0;r<o.length;r++){const{h:s,l:i}=ys(o[r],e);[t[r],n[r]]=[s,i]}return[t,n]}const ri=(o,e)=>BigInt(o>>>0)<<$n|BigInt(e>>>0),si=(o,e,t)=>o>>>t,oi=(o,e,t)=>o<<32-t|e>>>t,ii=(o,e,t)=>o>>>t|e<<32-t,ai=(o,e,t)=>o<<32-t|e>>>t,ci=(o,e,t)=>o<<64-t|e>>>t-32,ui=(o,e,t)=>o>>>t-32|e<<64-t,li=(o,e)=>e,di=(o,e)=>o,bs=(o,e,t)=>o<<t|e>>>32-t,ms=(o,e,t)=>e<<t|o>>>32-t,ks=(o,e,t)=>e<<t-32|o>>>64-t,ws=(o,e,t)=>o<<t-32|e>>>64-t;function hi(o,e,t,n){const r=(e>>>0)+(n>>>0);return{h:o+t+(r/2**32|0)|0,l:r|0}}const fi=(o,e,t)=>(o>>>0)+(e>>>0)+(t>>>0),pi=(o,e,t,n)=>e+t+n+(o/2**32|0)|0,yi=(o,e,t,n)=>(o>>>0)+(e>>>0)+(t>>>0)+(n>>>0),gi=(o,e,t,n,r)=>e+t+n+r+(o/2**32|0)|0,bi=(o,e,t,n,r)=>(o>>>0)+(e>>>0)+(t>>>0)+(n>>>0)+(r>>>0),mi=(o,e,t,n,r,s)=>e+t+n+r+s+(o/2**32|0)|0,U={fromBig:ys,split:gs,toBig:ri,shrSH:si,shrSL:oi,rotrSH:ii,rotrSL:ai,rotrBH:ci,rotrBL:ui,rotr32H:li,rotr32L:di,rotlSH:bs,rotlSL:ms,rotlBH:ks,rotlBL:ws,add:hi,add3L:fi,add3H:pi,add4L:yi,add4H:gi,add5H:mi,add5L:bi},Ss=[],Is=[],As=[],ki=BigInt(0),Kt=BigInt(1),wi=BigInt(2),Si=BigInt(7),Ii=BigInt(256),Ai=BigInt(113);for(let o=0,e=Kt,t=1,n=0;o<24;o++){[t,n]=[n,(2*t+3*n)%5],Ss.push(2*(5*n+t)),Is.push((o+1)*(o+2)/2%64);let r=ki;for(let s=0;s<7;s++)e=(e<<Kt^(e>>Si)*Ai)%Ii,e&wi&&(r^=Kt<<(Kt<<BigInt(s))-Kt);As.push(r)}const[_i,Ei]=gs(As,!0),Nr=(o,e,t)=>t>32?ks(o,e,t):bs(o,e,t),Kr=(o,e,t)=>t>32?ws(o,e,t):ms(o,e,t);function xi(o,e=24){const t=new Uint32Array(10);for(let n=24-e;n<24;n++){for(let i=0;i<10;i++)t[i]=o[i]^o[i+10]^o[i+20]^o[i+30]^o[i+40];for(let i=0;i<10;i+=2){const a=(i+8)%10,c=(i+2)%10,l=t[c],u=t[c+1],p=Nr(l,u,1)^t[a],b=Kr(l,u,1)^t[a+1];for(let f=0;f<50;f+=10)o[i+f]^=p,o[i+f+1]^=b}let r=o[2],s=o[3];for(let i=0;i<24;i++){const a=Is[i],c=Nr(r,s,a),l=Kr(r,s,a),u=Ss[i];r=o[u],s=o[u+1],o[u]=c,o[u+1]=l}for(let i=0;i<50;i+=10){for(let a=0;a<10;a++)t[a]=o[i+a];for(let a=0;a<10;a++)o[i+a]^=~t[(a+2)%10]&t[(a+4)%10]}o[0]^=_i[n],o[1]^=Ei[n]}t.fill(0)}class Xn extends Do{constructor(e,t,n,r=!1,s=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=n,this.enableXOF=r,this.rounds=s,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,Br(n),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=Mo(this.state)}keccak(){vr||Pr(this.state32),xi(this.state32,this.rounds),vr||Pr(this.state32),this.posOut=0,this.pos=0}update(e){Tr(this);const{blockLen:t,state:n}=this;e=qo(e);const r=e.length;for(let s=0;s<r;){const i=Math.min(t-this.pos,r-s);for(let a=0;a<i;a++)n[this.pos++]^=e[s++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:n,blockLen:r}=this;e[n]^=t,t&128&&n===r-1&&this.keccak(),e[r-1]^=128,this.keccak()}writeInto(e){Tr(this,!1),Ho(e),this.finish();const t=this.state,{blockLen:n}=this;for(let r=0,s=e.length;r<s;){this.posOut>=n&&this.keccak();const i=Math.min(n-this.posOut,s-r);e.set(t.subarray(this.posOut,this.posOut+i),r),this.posOut+=i,r+=i}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return Br(e),this.xofInto(new Uint8Array(e))}digestInto(e){if($o(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:n,outputLen:r,rounds:s,enableXOF:i}=this;return e||(e=new Xn(t,n,r,i,s)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=s,e.suffix=n,e.outputLen=r,e.enableXOF=i,e.destroyed=this.destroyed,e}}const Ri=(o,e,t)=>ds(()=>new Xn(e,o,t)),Wr=Ri(1,136,256/8),[Bi,vi]=U.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(o=>BigInt(o))),ot=new Uint32Array(80),it=new Uint32Array(80);class Pi extends Vo{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:n,Bl:r,Ch:s,Cl:i,Dh:a,Dl:c,Eh:l,El:u,Fh:p,Fl:b,Gh:f,Gl:m,Hh:y,Hl:w}=this;return[e,t,n,r,s,i,a,c,l,u,p,b,f,m,y,w]}set(e,t,n,r,s,i,a,c,l,u,p,b,f,m,y,w){this.Ah=e|0,this.Al=t|0,this.Bh=n|0,this.Bl=r|0,this.Ch=s|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=l|0,this.El=u|0,this.Fh=p|0,this.Fl=b|0,this.Gh=f|0,this.Gl=m|0,this.Hh=y|0,this.Hl=w|0}process(e,t){for(let x=0;x<16;x++,t+=4)ot[x]=e.getUint32(t),it[x]=e.getUint32(t+=4);for(let x=16;x<80;x++){const J=ot[x-15]|0,ve=it[x-15]|0,Fe=U.rotrSH(J,ve,1)^U.rotrSH(J,ve,8)^U.shrSH(J,ve,7),At=U.rotrSL(J,ve,1)^U.rotrSL(J,ve,8)^U.shrSL(J,ve,7),Ce=ot[x-2]|0,Ae=it[x-2]|0,_t=U.rotrSH(Ce,Ae,19)^U.rotrBH(Ce,Ae,61)^U.shrSH(Ce,Ae,6),ht=U.rotrSL(Ce,Ae,19)^U.rotrBL(Ce,Ae,61)^U.shrSL(Ce,Ae,6),Et=U.add4L(At,ht,it[x-7],it[x-16]),Ut=U.add4H(Et,Fe,_t,ot[x-7],ot[x-16]);ot[x]=Ut|0,it[x]=Et|0}let{Ah:n,Al:r,Bh:s,Bl:i,Ch:a,Cl:c,Dh:l,Dl:u,Eh:p,El:b,Fh:f,Fl:m,Gh:y,Gl:w,Hh:P,Hl:F}=this;for(let x=0;x<80;x++){const J=U.rotrSH(p,b,14)^U.rotrSH(p,b,18)^U.rotrBH(p,b,41),ve=U.rotrSL(p,b,14)^U.rotrSL(p,b,18)^U.rotrBL(p,b,41),Fe=p&f^~p&y,At=b&m^~b&w,Ce=U.add5L(F,ve,At,vi[x],it[x]),Ae=U.add5H(Ce,P,J,Fe,Bi[x],ot[x]),_t=Ce|0,ht=U.rotrSH(n,r,28)^U.rotrBH(n,r,34)^U.rotrBH(n,r,39),Et=U.rotrSL(n,r,28)^U.rotrBL(n,r,34)^U.rotrBL(n,r,39),Ut=n&s^n&a^s&a,En=r&i^r&c^i&c;P=y|0,F=w|0,y=f|0,w=m|0,f=p|0,m=b|0,{h:p,l:b}=U.add(l|0,u|0,Ae|0,_t|0),l=a|0,u=c|0,a=s|0,c=i|0,s=n|0,i=r|0;const xn=U.add3L(_t,Et,En);n=U.add3H(xn,Ae,ht,Ut),r=xn|0}({h:n,l:r}=U.add(this.Ah|0,this.Al|0,n|0,r|0)),{h:s,l:i}=U.add(this.Bh|0,this.Bl|0,s|0,i|0),{h:a,l:c}=U.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:l,l:u}=U.add(this.Dh|0,this.Dl|0,l|0,u|0),{h:p,l:b}=U.add(this.Eh|0,this.El|0,p|0,b|0),{h:f,l:m}=U.add(this.Fh|0,this.Fl|0,f|0,m|0),{h:y,l:w}=U.add(this.Gh|0,this.Gl|0,y|0,w|0),{h:P,l:F}=U.add(this.Hh|0,this.Hl|0,P|0,F|0),this.set(n,r,s,i,a,c,l,u,p,b,f,m,y,w,P,F)}roundClean(){ot.fill(0),it.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const Ti=ds(()=>new Pi);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ne=BigInt(0),Ee=BigInt(1),Qt=BigInt(2),Li=BigInt(8),Ci={zip215:!0};function Oi(o){const e=jo(o);return Go(o,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function zi(o){const e=Oi(o),{Fp:t,n,prehash:r,hash:s,randomBytes:i,nByteLength:a,h:c}=e,l=Qt<<BigInt(a*8)-Ee,u=t.create,p=hs(e.n,e.nBitLength),b=e.uvRatio||((z,A)=>{try{return{isValid:!0,value:t.sqrt(z*t.inv(A))}}catch{return{isValid:!1,value:Ne}}}),f=e.adjustScalarBytes||(z=>z),m=e.domain||((z,A,C)=>{if(Bn("phflag",C),A.length||C)throw new Error("Contexts/pre-hash are not supported");return z});function y(z,A){Nt("coordinate "+z,A,Ne,l)}function w(z){if(!(z instanceof x))throw new Error("ExtendedPoint expected")}const P=Or((z,A)=>{const{ex:C,ey:O,ez:q}=z,V=z.is0();A==null&&(A=V?Li:t.inv(q));const X=u(C*A),oe=u(O*A),Z=u(q*A);if(V)return{x:Ne,y:Ee};if(Z!==Ee)throw new Error("invZ was invalid");return{x:X,y:oe}}),F=Or(z=>{const{a:A,d:C}=e;if(z.is0())throw new Error("bad point: ZERO");const{ex:O,ey:q,ez:V,et:X}=z,oe=u(O*O),Z=u(q*q),ie=u(V*V),ue=u(ie*ie),_e=u(oe*A),De=u(ie*u(_e+Z)),Me=u(ue+u(C*u(oe*Z)));if(De!==Me)throw new Error("bad point: equation left != right (1)");const Oe=u(O*q),st=u(V*X);if(Oe!==st)throw new Error("bad point: equation left != right (2)");return!0});class x{constructor(A,C,O,q){this.ex=A,this.ey=C,this.ez=O,this.et=q,y("x",A),y("y",C),y("z",O),y("t",q),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(A){if(A instanceof x)throw new Error("extended point not allowed");const{x:C,y:O}=A||{};return y("x",C),y("y",O),new x(C,O,Ee,u(C*O))}static normalizeZ(A){const C=t.invertBatch(A.map(O=>O.ez));return A.map((O,q)=>O.toAffine(C[q])).map(x.fromAffine)}static msm(A,C){return Yo(x,p,A,C)}_setWindowSize(A){Fe.setWindowSize(this,A)}assertValidity(){F(this)}equals(A){w(A);const{ex:C,ey:O,ez:q}=this,{ex:V,ey:X,ez:oe}=A,Z=u(C*oe),ie=u(V*q),ue=u(O*oe),_e=u(X*q);return Z===ie&&ue===_e}is0(){return this.equals(x.ZERO)}negate(){return new x(u(-this.ex),this.ey,this.ez,u(-this.et))}double(){const{a:A}=e,{ex:C,ey:O,ez:q}=this,V=u(C*C),X=u(O*O),oe=u(Qt*u(q*q)),Z=u(A*V),ie=C+O,ue=u(u(ie*ie)-V-X),_e=Z+X,De=_e-oe,Me=Z-X,Oe=u(ue*De),st=u(_e*Me),ft=u(ue*Me),Xt=u(De*_e);return new x(Oe,st,Xt,ft)}add(A){w(A);const{a:C,d:O}=e,{ex:q,ey:V,ez:X,et:oe}=this,{ex:Z,ey:ie,ez:ue,et:_e}=A;if(C===BigInt(-1)){const Sr=u((V-q)*(ie+Z)),Ir=u((V+q)*(ie-Z)),Rn=u(Ir-Sr);if(Rn===Ne)return this.double();const Ar=u(X*Qt*_e),_r=u(oe*Qt*ue),Er=_r+Ar,xr=Ir+Sr,Rr=_r-Ar,zo=u(Er*Rn),Uo=u(xr*Rr),No=u(Er*Rr),Ko=u(Rn*xr);return new x(zo,Uo,Ko,No)}const De=u(q*Z),Me=u(V*ie),Oe=u(oe*O*_e),st=u(X*ue),ft=u((q+V)*(Z+ie)-De-Me),Xt=st-Oe,kr=st+Oe,wr=u(Me-C*De),To=u(ft*Xt),Lo=u(kr*wr),Co=u(ft*wr),Oo=u(Xt*kr);return new x(To,Lo,Oo,Co)}subtract(A){return this.add(A.negate())}wNAF(A){return Fe.wNAFCached(this,A,x.normalizeZ)}multiply(A){const C=A;Nt("scalar",C,Ee,n);const{p:O,f:q}=this.wNAF(C);return x.normalizeZ([O,q])[0]}multiplyUnsafe(A,C=x.ZERO){const O=A;return Nt("scalar",O,Ne,n),O===Ne?ve:this.is0()||O===Ee?this:Fe.wNAFCachedUnsafe(this,O,x.normalizeZ,C)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}isTorsionFree(){return Fe.unsafeLadder(this,n).is0()}toAffine(A){return P(this,A)}clearCofactor(){const{h:A}=e;return A===Ee?this:this.multiplyUnsafe(A)}static fromHex(A,C=!1){const{d:O,a:q}=e,V=t.BYTES;A=Ze("pointHex",A,V),Bn("zip215",C);const X=A.slice(),oe=A[V-1];X[V-1]=oe&-129;const Z=vn(X),ie=C?l:t.ORDER;Nt("pointHex.y",Z,Ne,ie);const ue=u(Z*Z),_e=u(ue-Ee),De=u(O*ue-q);let{isValid:Me,value:Oe}=b(_e,De);if(!Me)throw new Error("Point.fromHex: invalid y coordinate");const st=(Oe&Ee)===Ee,ft=(oe&128)!==0;if(!C&&Oe===Ne&&ft)throw new Error("Point.fromHex: x=0 and x_0=1");return ft!==st&&(Oe=u(-Oe)),x.fromAffine({x:Oe,y:Z})}static fromPrivateKey(A){return Ae(A).point}toRawBytes(){const{x:A,y:C}=this.toAffine(),O=Lr(C,t.BYTES);return O[O.length-1]|=A&Ee?128:0,O}toHex(){return Jo(this.toRawBytes())}}x.BASE=new x(e.Gx,e.Gy,Ee,u(e.Gx*e.Gy)),x.ZERO=new x(Ne,Ee,Ee,Ne);const{BASE:J,ZERO:ve}=x,Fe=Xo(x,a*8);function At(z){return Qe(z,n)}function Ce(z){return At(vn(z))}function Ae(z){const A=t.BYTES;z=Ze("private key",z,A);const C=Ze("hashed private key",s(z),2*A),O=f(C.slice(0,A)),q=C.slice(A,2*A),V=Ce(O),X=J.multiply(V),oe=X.toRawBytes();return{head:O,prefix:q,scalar:V,point:X,pointBytes:oe}}function _t(z){return Ae(z).pointBytes}function ht(z=new Uint8Array,...A){const C=Cr(...A);return Ce(s(m(C,Ze("context",z),!!r)))}function Et(z,A,C={}){z=Ze("message",z),r&&(z=r(z));const{prefix:O,scalar:q,pointBytes:V}=Ae(A),X=ht(C.context,O,z),oe=J.multiply(X).toRawBytes(),Z=ht(C.context,oe,V,z),ie=At(X+Z*q);Nt("signature.s",ie,Ne,n);const ue=Cr(oe,Lr(ie,t.BYTES));return Ze("result",ue,t.BYTES*2)}const Ut=Ci;function En(z,A,C,O=Ut){const{context:q,zip215:V}=O,X=t.BYTES;z=Ze("signature",z,2*X),A=Ze("message",A),C=Ze("publicKey",C,X),V!==void 0&&Bn("zip215",V),r&&(A=r(A));const oe=vn(z.slice(X,2*X));let Z,ie,ue;try{Z=x.fromHex(C,V),ie=x.fromHex(z.slice(0,X),V),ue=J.multiplyUnsafe(oe)}catch{return!1}if(!V&&Z.isSmallOrder())return!1;const _e=ht(q,ie.toRawBytes(),Z.toRawBytes(),A);return ie.add(Z.multiplyUnsafe(_e)).subtract(ue).clearCofactor().equals(x.ZERO)}return J._setWindowSize(8),{CURVE:e,getPublicKey:_t,sign:Et,verify:En,ExtendedPoint:x,utils:{getExtendedPublicKey:Ae,randomPrivateKey:()=>i(t.BYTES),precompute(z=8,A=x.BASE){return A._setWindowSize(z),A.multiply(BigInt(3)),A}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Zn=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Fr=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const Ui=BigInt(1),Dr=BigInt(2);BigInt(3);const Ni=BigInt(5),Ki=BigInt(8);function Wi(o){const e=BigInt(10),t=BigInt(20),n=BigInt(40),r=BigInt(80),s=Zn,a=o*o%s*o%s,c=qe(a,Dr,s)*a%s,l=qe(c,Ui,s)*o%s,u=qe(l,Ni,s)*l%s,p=qe(u,e,s)*u%s,b=qe(p,t,s)*p%s,f=qe(b,n,s)*b%s,m=qe(f,r,s)*f%s,y=qe(m,r,s)*f%s,w=qe(y,e,s)*u%s;return{pow_p_5_8:qe(w,Dr,s)*o%s,b2:a}}function Fi(o){return o[0]&=248,o[31]&=127,o[31]|=64,o}function Di(o,e){const t=Zn,n=Qe(e*e*e,t),r=Qe(n*n*e,t),s=Wi(o*r).pow_p_5_8;let i=Qe(o*n*s,t);const a=Qe(e*i*i,t),c=i,l=Qe(i*Fr,t),u=a===o,p=a===Qe(-o,t),b=a===Qe(-o*Fr,t);return u&&(i=c),(p||b)&&(i=l),Qo(i,t)&&(i=Qe(-i,t)),{isValid:u||p,value:i}}const Mi=hs(Zn,void 0,!0),qi={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:Mi,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:Ki,Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:Ti,randomBytes:Zo,adjustScalarBytes:Fi,uvRatio:Di},Tt=zi(qi);var fe={};function tt(o,e,t){return e<=o&&o<=t}function yn(o){if(o===void 0)return{};if(o===Object(o))return o;throw TypeError("Could not convert argument to dictionary")}function Hi(o){for(var e=String(o),t=e.length,n=0,r=[];n<t;){var s=e.charCodeAt(n);if(s<55296||s>57343)r.push(s);else if(56320<=s&&s<=57343)r.push(65533);else if(55296<=s&&s<=56319)if(n===t-1)r.push(65533);else{var i=o.charCodeAt(n+1);if(56320<=i&&i<=57343){var a=s&1023,c=i&1023;r.push(65536+(a<<10)+c),n+=1}else r.push(65533)}n+=1}return r}function $i(o){for(var e="",t=0;t<o.length;++t){var n=o[t];n<=65535?e+=String.fromCharCode(n):(n-=65536,e+=String.fromCharCode((n>>10)+55296,(n&1023)+56320))}return e}var rn=-1;function Qn(o){this.tokens=[].slice.call(o)}Qn.prototype={endOfStream:function(){return!this.tokens.length},read:function(){return this.tokens.length?this.tokens.shift():rn},prepend:function(o){if(Array.isArray(o))for(var e=o;e.length;)this.tokens.unshift(e.pop());else this.tokens.unshift(o)},push:function(o){if(Array.isArray(o))for(var e=o;e.length;)this.tokens.push(e.shift());else this.tokens.push(o)}};var Rt=-1;function Pn(o,e){if(o)throw TypeError("Decoder error");return e||65533}var sn="utf-8";function on(o,e){if(!(this instanceof on))return new on(o,e);if(o=o!==void 0?String(o).toLowerCase():sn,o!==sn)throw new Error("Encoding not supported. Only utf-8 is supported");e=yn(e),this._streaming=!1,this._BOMseen=!1,this._decoder=null,this._fatal=!!e.fatal,this._ignoreBOM=!!e.ignoreBOM,Object.defineProperty(this,"encoding",{value:"utf-8"}),Object.defineProperty(this,"fatal",{value:this._fatal}),Object.defineProperty(this,"ignoreBOM",{value:this._ignoreBOM})}on.prototype={decode:function(e,t){var n;typeof e=="object"&&e instanceof ArrayBuffer?n=new Uint8Array(e):typeof e=="object"&&"buffer"in e&&e.buffer instanceof ArrayBuffer?n=new Uint8Array(e.buffer,e.byteOffset,e.byteLength):n=new Uint8Array(0),t=yn(t),this._streaming||(this._decoder=new Vi({fatal:this._fatal}),this._BOMseen=!1),this._streaming=!!t.stream;for(var r=new Qn(n),s=[],i;!r.endOfStream()&&(i=this._decoder.handler(r,r.read()),i!==Rt);)i!==null&&(Array.isArray(i)?s.push.apply(s,i):s.push(i));if(!this._streaming){do{if(i=this._decoder.handler(r,r.read()),i===Rt)break;i!==null&&(Array.isArray(i)?s.push.apply(s,i):s.push(i))}while(!r.endOfStream());this._decoder=null}return s.length&&["utf-8"].indexOf(this.encoding)!==-1&&!this._ignoreBOM&&!this._BOMseen&&(s[0]===65279?(this._BOMseen=!0,s.shift()):this._BOMseen=!0),$i(s)}};function an(o,e){if(!(this instanceof an))return new an(o,e);if(o=o!==void 0?String(o).toLowerCase():sn,o!==sn)throw new Error("Encoding not supported. Only utf-8 is supported");e=yn(e),this._streaming=!1,this._encoder=null,this._options={fatal:!!e.fatal},Object.defineProperty(this,"encoding",{value:"utf-8"})}an.prototype={encode:function(e,t){e=e?String(e):"",t=yn(t),this._streaming||(this._encoder=new ji(this._options)),this._streaming=!!t.stream;for(var n=[],r=new Qn(Hi(e)),s;!r.endOfStream()&&(s=this._encoder.handler(r,r.read()),s!==Rt);)Array.isArray(s)?n.push.apply(n,s):n.push(s);if(!this._streaming){for(;s=this._encoder.handler(r,r.read()),s!==Rt;)Array.isArray(s)?n.push.apply(n,s):n.push(s);this._encoder=null}return new Uint8Array(n)}};function Vi(o){var e=o.fatal,t=0,n=0,r=0,s=128,i=191;this.handler=function(a,c){if(c===rn&&r!==0)return r=0,Pn(e);if(c===rn)return Rt;if(r===0){if(tt(c,0,127))return c;if(tt(c,194,223))r=1,t=c-192;else if(tt(c,224,239))c===224&&(s=160),c===237&&(i=159),r=2,t=c-224;else if(tt(c,240,244))c===240&&(s=144),c===244&&(i=143),r=3,t=c-240;else return Pn(e);return t=t<<6*r,null}if(!tt(c,s,i))return t=r=n=0,s=128,i=191,a.prepend(c),Pn(e);if(s=128,i=191,n+=1,t+=c-128<<6*(r-n),n!==r)return null;var l=t;return t=r=n=0,l}}function ji(o){o.fatal,this.handler=function(e,t){if(t===rn)return Rt;if(tt(t,0,127))return t;var n,r;tt(t,128,2047)?(n=1,r=192):tt(t,2048,65535)?(n=2,r=224):tt(t,65536,1114111)&&(n=3,r=240);for(var s=[(t>>6*n)+r];n>0;){var i=t>>6*(n-1);s.push(128|i&63),n-=1}return s}}const Gi=Object.freeze(Object.defineProperty({__proto__:null,TextDecoder:on,TextEncoder:an},Symbol.toStringTag,{value:"Module"})),Yi=fs(Gi);var Ji=Ve&&Ve.__createBinding||(Object.create?function(o,e,t,n){n===void 0&&(n=t),Object.defineProperty(o,n,{enumerable:!0,get:function(){return e[t]}})}:function(o,e,t,n){n===void 0&&(n=t),o[n]=e[t]}),Xi=Ve&&Ve.__setModuleDefault||(Object.create?function(o,e){Object.defineProperty(o,"default",{enumerable:!0,value:e})}:function(o,e){o.default=e}),Ye=Ve&&Ve.__decorate||function(o,e,t,n){var r=arguments.length,s=r<3?e:n===null?n=Object.getOwnPropertyDescriptor(e,t):n,i;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")s=Reflect.decorate(o,e,t,n);else for(var a=o.length-1;a>=0;a--)(i=o[a])&&(s=(r<3?i(s):r>3?i(e,t,s):i(e,t))||s);return r>3&&s&&Object.defineProperty(e,t,s),s},Zi=Ve&&Ve.__importStar||function(o){if(o&&o.__esModule)return o;var e={};if(o!=null)for(var t in o)t!=="default"&&Object.hasOwnProperty.call(o,t)&&Ji(e,o,t);return Xi(e,o),e},_s=Ve&&Ve.__importDefault||function(o){return o&&o.__esModule?o:{default:o}};Object.defineProperty(fe,"__esModule",{value:!0});var Es=fe.deserializeUnchecked=Ts=fe.deserialize=Ps=fe.serialize=fe.BinaryReader=fe.BinaryWriter=fe.BorshError=fe.baseDecode=fe.baseEncode=void 0;const ut=_s(ei),xs=_s(ti),Qi=Zi(Yi),ea=typeof TextDecoder!="function"?Qi.TextDecoder:TextDecoder,ta=new ea("utf-8",{fatal:!0});function na(o){return typeof o=="string"&&(o=Buffer.from(o,"utf8")),xs.default.encode(Buffer.from(o))}fe.baseEncode=na;function ra(o){return Buffer.from(xs.default.decode(o))}fe.baseDecode=ra;const Tn=1024;class Se extends Error{constructor(e){super(e),this.fieldPath=[],this.originalMessage=e}addToFieldPath(e){this.fieldPath.splice(0,0,e),this.message=this.originalMessage+": "+this.fieldPath.join(".")}}fe.BorshError=Se;class Rs{constructor(){this.buf=Buffer.alloc(Tn),this.length=0}maybeResize(){this.buf.length<16+this.length&&(this.buf=Buffer.concat([this.buf,Buffer.alloc(Tn)]))}writeU8(e){this.maybeResize(),this.buf.writeUInt8(e,this.length),this.length+=1}writeU16(e){this.maybeResize(),this.buf.writeUInt16LE(e,this.length),this.length+=2}writeU32(e){this.maybeResize(),this.buf.writeUInt32LE(e,this.length),this.length+=4}writeU64(e){this.maybeResize(),this.writeBuffer(Buffer.from(new ut.default(e).toArray("le",8)))}writeU128(e){this.maybeResize(),this.writeBuffer(Buffer.from(new ut.default(e).toArray("le",16)))}writeU256(e){this.maybeResize(),this.writeBuffer(Buffer.from(new ut.default(e).toArray("le",32)))}writeU512(e){this.maybeResize(),this.writeBuffer(Buffer.from(new ut.default(e).toArray("le",64)))}writeBuffer(e){this.buf=Buffer.concat([Buffer.from(this.buf.subarray(0,this.length)),e,Buffer.alloc(Tn)]),this.length+=e.length}writeString(e){this.maybeResize();const t=Buffer.from(e,"utf8");this.writeU32(t.length),this.writeBuffer(t)}writeFixedArray(e){this.writeBuffer(Buffer.from(e))}writeArray(e,t){this.maybeResize(),this.writeU32(e.length);for(const n of e)this.maybeResize(),t(n)}toArray(){return this.buf.subarray(0,this.length)}}fe.BinaryWriter=Rs;function Je(o,e,t){const n=t.value;t.value=function(...r){try{return n.apply(this,r)}catch(s){if(s instanceof RangeError){const i=s.code;if(["ERR_BUFFER_OUT_OF_BOUNDS","ERR_OUT_OF_RANGE"].indexOf(i)>=0)throw new Se("Reached the end of buffer when deserializing")}throw s}}}class Le{constructor(e){this.buf=e,this.offset=0}readU8(){const e=this.buf.readUInt8(this.offset);return this.offset+=1,e}readU16(){const e=this.buf.readUInt16LE(this.offset);return this.offset+=2,e}readU32(){const e=this.buf.readUInt32LE(this.offset);return this.offset+=4,e}readU64(){const e=this.readBuffer(8);return new ut.default(e,"le")}readU128(){const e=this.readBuffer(16);return new ut.default(e,"le")}readU256(){const e=this.readBuffer(32);return new ut.default(e,"le")}readU512(){const e=this.readBuffer(64);return new ut.default(e,"le")}readBuffer(e){if(this.offset+e>this.buf.length)throw new Se(`Expected buffer length ${e} isn't within bounds`);const t=this.buf.slice(this.offset,this.offset+e);return this.offset+=e,t}readString(){const e=this.readU32(),t=this.readBuffer(e);try{return ta.decode(t)}catch(n){throw new Se(`Error decoding UTF-8 string: ${n}`)}}readFixedArray(e){return new Uint8Array(this.readBuffer(e))}readArray(e){const t=this.readU32(),n=Array();for(let r=0;r<t;++r)n.push(e());return n}}Ye([Je],Le.prototype,"readU8",null);Ye([Je],Le.prototype,"readU16",null);Ye([Je],Le.prototype,"readU32",null);Ye([Je],Le.prototype,"readU64",null);Ye([Je],Le.prototype,"readU128",null);Ye([Je],Le.prototype,"readU256",null);Ye([Je],Le.prototype,"readU512",null);Ye([Je],Le.prototype,"readString",null);Ye([Je],Le.prototype,"readFixedArray",null);Ye([Je],Le.prototype,"readArray",null);fe.BinaryReader=Le;function Bs(o){return o.charAt(0).toUpperCase()+o.slice(1)}function pt(o,e,t,n,r){try{if(typeof n=="string")r[`write${Bs(n)}`](t);else if(n instanceof Array)if(typeof n[0]=="number"){if(t.length!==n[0])throw new Se(`Expecting byte array of length ${n[0]}, but got ${t.length} bytes`);r.writeFixedArray(t)}else if(n.length===2&&typeof n[1]=="number"){if(t.length!==n[1])throw new Se(`Expecting byte array of length ${n[1]}, but got ${t.length} bytes`);for(let s=0;s<n[1];s++)pt(o,null,t[s],n[0],r)}else r.writeArray(t,s=>{pt(o,e,s,n[0],r)});else if(n.kind!==void 0)switch(n.kind){case"option":{t==null?r.writeU8(0):(r.writeU8(1),pt(o,e,t,n.type,r));break}case"map":{r.writeU32(t.size),t.forEach((s,i)=>{pt(o,e,i,n.key,r),pt(o,e,s,n.value,r)});break}default:throw new Se(`FieldType ${n} unrecognized`)}else vs(o,t,r)}catch(s){throw s instanceof Se&&s.addToFieldPath(e),s}}function vs(o,e,t){if(typeof e.borshSerialize=="function"){e.borshSerialize(t);return}const n=o.get(e.constructor);if(!n)throw new Se(`Class ${e.constructor.name} is missing in schema`);if(n.kind==="struct")n.fields.map(([r,s])=>{pt(o,r,e[r],s,t)});else if(n.kind==="enum"){const r=e[n.field];for(let s=0;s<n.values.length;++s){const[i,a]=n.values[s];if(i===r){t.writeU8(s),pt(o,i,e[i],a,t);break}}}else throw new Se(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function sa(o,e,t=Rs){const n=new t;return vs(o,e,n),n.toArray()}var Ps=fe.serialize=sa;function yt(o,e,t,n){try{if(typeof t=="string")return n[`read${Bs(t)}`]();if(t instanceof Array){if(typeof t[0]=="number")return n.readFixedArray(t[0]);if(typeof t[1]=="number"){const r=[];for(let s=0;s<t[1];s++)r.push(yt(o,null,t[0],n));return r}else return n.readArray(()=>yt(o,e,t[0],n))}if(t.kind==="option")return n.readU8()?yt(o,e,t.type,n):void 0;if(t.kind==="map"){let r=new Map;const s=n.readU32();for(let i=0;i<s;i++){const a=yt(o,e,t.key,n),c=yt(o,e,t.value,n);r.set(a,c)}return r}return er(o,t,n)}catch(r){throw r instanceof Se&&r.addToFieldPath(e),r}}function er(o,e,t){if(typeof e.borshDeserialize=="function")return e.borshDeserialize(t);const n=o.get(e);if(!n)throw new Se(`Class ${e.name} is missing in schema`);if(n.kind==="struct"){const r={};for(const[s,i]of o.get(e).fields)r[s]=yt(o,s,i,t);return new e(r)}if(n.kind==="enum"){const r=t.readU8();if(r>=n.values.length)throw new Se(`Enum index: ${r} is out of range`);const[s,i]=n.values[r],a=yt(o,s,i,t);return new e({[s]:a})}throw new Se(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)}function oa(o,e,t,n=Le){const r=new n(t),s=er(o,e,r);if(r.offset<t.length)throw new Se(`Unexpected ${t.length-r.offset} bytes after deserialized data`);return s}var Ts=fe.deserialize=oa;function ia(o,e,t,n=Le){const r=new n(t);return er(o,e,r)}Es=fe.deserializeUnchecked=ia;var h={};Object.defineProperty(h,"__esModule",{value:!0});h.s16=h.s8=h.nu64be=h.u48be=h.u40be=h.u32be=h.u24be=h.u16be=de=h.nu64=h.u48=h.u40=R=h.u32=h.u24=ze=h.u16=M=h.u8=dt=h.offset=h.greedy=h.Constant=h.UTF8=h.CString=h.Blob=h.Boolean=h.BitField=h.BitStructure=h.VariantLayout=h.Union=h.UnionLayoutDiscriminator=h.UnionDiscriminator=h.Structure=h.Sequence=h.DoubleBE=h.Double=h.FloatBE=h.Float=h.NearInt64BE=h.NearInt64=h.NearUInt64BE=h.NearUInt64=h.IntBE=h.Int=h.UIntBE=h.UInt=h.OffsetLayout=h.GreedyCount=h.ExternalLayout=h.bindConstructorLayout=h.nameWithProperty=h.Layout=h.uint8ArrayToBuffer=h.checkUint8Array=void 0;h.constant=h.utf8=h.cstr=ne=h.blob=h.unionLayoutDiscriminator=h.union=ge=h.seq=h.bits=B=h.struct=h.f64be=h.f64=h.f32be=h.f32=h.ns64be=h.s48be=h.s40be=h.s32be=h.s24be=h.s16be=Pe=h.ns64=h.s48=h.s40=h.s32=h.s24=void 0;const tr=T;function Lt(o){if(!(o instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}h.checkUint8Array=Lt;function $(o){return Lt(o),tr.Buffer.from(o.buffer,o.byteOffset,o.length)}h.uint8ArrayToBuffer=$;class Y{constructor(e,t){if(!Number.isInteger(e))throw new TypeError("span must be an integer");this.span=e,this.property=t}makeDestinationObject(){return{}}getSpan(e,t){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(e){const t=Object.create(this.constructor.prototype);return Object.assign(t,this),t.property=e,t}fromArray(e){}}h.Layout=Y;function nr(o,e){return e.property?o+"["+e.property+"]":o}h.nameWithProperty=nr;function aa(o,e){if(typeof o!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(o,"layout_"))throw new Error("Class is already bound to a layout");if(!(e&&e instanceof Y))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(e,"boundConstructor_"))throw new Error("layout is already bound to a constructor");o.layout_=e,e.boundConstructor_=o,e.makeDestinationObject=()=>new o,Object.defineProperty(o.prototype,"encode",{value(t,n){return e.encode(this,t,n)},writable:!0}),Object.defineProperty(o,"decode",{value(t,n){return e.decode(t,n)},writable:!0})}h.bindConstructorLayout=aa;class Be extends Y{isCount(){throw new Error("ExternalLayout is abstract")}}h.ExternalLayout=Be;class Ls extends Be{constructor(e=1,t){if(!Number.isInteger(e)||0>=e)throw new TypeError("elementSpan must be a (positive) integer");super(-1,t),this.elementSpan=e}isCount(){return!0}decode(e,t=0){Lt(e);const n=e.length-t;return Math.floor(n/this.elementSpan)}encode(e,t,n){return 0}}h.GreedyCount=Ls;class rr extends Be{constructor(e,t=0,n){if(!(e instanceof Y))throw new TypeError("layout must be a Layout");if(!Number.isInteger(t))throw new TypeError("offset must be integer or undefined");super(e.span,n||e.property),this.layout=e,this.offset=t}isCount(){return this.layout instanceof Ue||this.layout instanceof Ke}decode(e,t=0){return this.layout.decode(e,t+this.offset)}encode(e,t,n=0){return this.layout.encode(e,t,n+this.offset)}}h.OffsetLayout=rr;class Ue extends Y{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return $(e).readUIntLE(t,this.span)}encode(e,t,n=0){return $(t).writeUIntLE(e,n,this.span),this.span}}h.UInt=Ue;class Ke extends Y{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return $(e).readUIntBE(t,this.span)}encode(e,t,n=0){return $(t).writeUIntBE(e,n,this.span),this.span}}h.UIntBE=Ke;class kt extends Y{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return $(e).readIntLE(t,this.span)}encode(e,t,n=0){return $(t).writeIntLE(e,n,this.span),this.span}}h.Int=kt;class Ct extends Y{constructor(e,t){if(super(e,t),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(e,t=0){return $(e).readIntBE(t,this.span)}encode(e,t,n=0){return $(t).writeIntBE(e,n,this.span),this.span}}h.IntBE=Ct;const Vn=Math.pow(2,32);function gn(o){const e=Math.floor(o/Vn),t=o-e*Vn;return{hi32:e,lo32:t}}function bn(o,e){return o*Vn+e}class Cs extends Y{constructor(e){super(8,e)}decode(e,t=0){const n=$(e),r=n.readUInt32LE(t),s=n.readUInt32LE(t+4);return bn(s,r)}encode(e,t,n=0){const r=gn(e),s=$(t);return s.writeUInt32LE(r.lo32,n),s.writeUInt32LE(r.hi32,n+4),8}}h.NearUInt64=Cs;class Os extends Y{constructor(e){super(8,e)}decode(e,t=0){const n=$(e),r=n.readUInt32BE(t),s=n.readUInt32BE(t+4);return bn(r,s)}encode(e,t,n=0){const r=gn(e),s=$(t);return s.writeUInt32BE(r.hi32,n),s.writeUInt32BE(r.lo32,n+4),8}}h.NearUInt64BE=Os;class zs extends Y{constructor(e){super(8,e)}decode(e,t=0){const n=$(e),r=n.readUInt32LE(t),s=n.readInt32LE(t+4);return bn(s,r)}encode(e,t,n=0){const r=gn(e),s=$(t);return s.writeUInt32LE(r.lo32,n),s.writeInt32LE(r.hi32,n+4),8}}h.NearInt64=zs;class Us extends Y{constructor(e){super(8,e)}decode(e,t=0){const n=$(e),r=n.readInt32BE(t),s=n.readUInt32BE(t+4);return bn(r,s)}encode(e,t,n=0){const r=gn(e),s=$(t);return s.writeInt32BE(r.hi32,n),s.writeUInt32BE(r.lo32,n+4),8}}h.NearInt64BE=Us;class Ns extends Y{constructor(e){super(4,e)}decode(e,t=0){return $(e).readFloatLE(t)}encode(e,t,n=0){return $(t).writeFloatLE(e,n),4}}h.Float=Ns;class Ks extends Y{constructor(e){super(4,e)}decode(e,t=0){return $(e).readFloatBE(t)}encode(e,t,n=0){return $(t).writeFloatBE(e,n),4}}h.FloatBE=Ks;class Ws extends Y{constructor(e){super(8,e)}decode(e,t=0){return $(e).readDoubleLE(t)}encode(e,t,n=0){return $(t).writeDoubleLE(e,n),8}}h.Double=Ws;class Fs extends Y{constructor(e){super(8,e)}decode(e,t=0){return $(e).readDoubleBE(t)}encode(e,t,n=0){return $(t).writeDoubleBE(e,n),8}}h.DoubleBE=Fs;class Ds extends Y{constructor(e,t,n){if(!(e instanceof Y))throw new TypeError("elementLayout must be a Layout");if(!(t instanceof Be&&t.isCount()||Number.isInteger(t)&&0<=t))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let r=-1;!(t instanceof Be)&&0<e.span&&(r=t*e.span),super(r,n),this.elementLayout=e,this.count=t}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0,r=this.count;if(r instanceof Be&&(r=r.decode(e,t)),0<this.elementLayout.span)n=r*this.elementLayout.span;else{let s=0;for(;s<r;)n+=this.elementLayout.getSpan(e,t+n),++s}return n}decode(e,t=0){const n=[];let r=0,s=this.count;for(s instanceof Be&&(s=s.decode(e,t));r<s;)n.push(this.elementLayout.decode(e,t)),t+=this.elementLayout.getSpan(e,t),r+=1;return n}encode(e,t,n=0){const r=this.elementLayout,s=e.reduce((i,a)=>i+r.encode(a,t,n+i),0);return this.count instanceof Be&&this.count.encode(e.length,t,n),s}}h.Sequence=Ds;class Ms extends Y{constructor(e,t,n){if(!(Array.isArray(e)&&e.reduce((s,i)=>s&&i instanceof Y,!0)))throw new TypeError("fields must be array of Layout instances");typeof t=="boolean"&&n===void 0&&(n=t,t=void 0);for(const s of e)if(0>s.span&&s.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let r=-1;try{r=e.reduce((s,i)=>s+i.getSpan(),0)}catch{}super(r,t),this.fields=e,this.decodePrefixes=!!n}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;try{n=this.fields.reduce((r,s)=>{const i=s.getSpan(e,t);return t+=i,r+i},0)}catch{throw new RangeError("indeterminate span")}return n}decode(e,t=0){Lt(e);const n=this.makeDestinationObject();for(const r of this.fields)if(r.property!==void 0&&(n[r.property]=r.decode(e,t)),t+=r.getSpan(e,t),this.decodePrefixes&&e.length===t)break;return n}encode(e,t,n=0){const r=n;let s=0,i=0;for(const a of this.fields){let c=a.span;if(i=0<c?c:0,a.property!==void 0){const l=e[a.property];l!==void 0&&(i=a.encode(l,t,n),0>c&&(c=a.getSpan(t,n)))}s=n,n+=c}return s+i-r}fromArray(e){const t=this.makeDestinationObject();for(const n of this.fields)n.property!==void 0&&0<e.length&&(t[n.property]=e.shift());return t}layoutFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}offsetOf(e){if(typeof e!="string")throw new TypeError("property must be string");let t=0;for(const n of this.fields){if(n.property===e)return t;0>n.span?t=-1:0<=t&&(t+=n.span)}}}h.Structure=Ms;class sr{constructor(e){this.property=e}decode(e,t){throw new Error("UnionDiscriminator is abstract")}encode(e,t,n){throw new Error("UnionDiscriminator is abstract")}}h.UnionDiscriminator=sr;class cn extends sr{constructor(e,t){if(!(e instanceof Be&&e.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(t||e.property||"variant"),this.layout=e}decode(e,t){return this.layout.decode(e,t)}encode(e,t,n){return this.layout.encode(e,t,n)}}h.UnionLayoutDiscriminator=cn;class or extends Y{constructor(e,t,n){let r;if(e instanceof Ue||e instanceof Ke)r=new cn(new rr(e));else if(e instanceof Be&&e.isCount())r=new cn(e);else if(e instanceof sr)r=e;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(t===void 0&&(t=null),!(t===null||t instanceof Y))throw new TypeError("defaultLayout must be null or a Layout");if(t!==null){if(0>t.span)throw new Error("defaultLayout must have constant span");t.property===void 0&&(t=t.replicate("content"))}let s=-1;t&&(s=t.span,0<=s&&(e instanceof Ue||e instanceof Ke)&&(s+=r.layout.span)),super(s,n),this.discriminator=r,this.usesPrefixDiscriminator=e instanceof Ue||e instanceof Ke,this.defaultLayout=t,this.registry={};let i=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(a){return i(a)},this.configGetSourceVariant=function(a){i=a.bind(this)}}getSpan(e,t=0){if(0<=this.span)return this.span;const n=this.getVariant(e,t);if(!n)throw new Error("unable to determine span for unrecognized variant");return n.getSpan(e,t)}defaultGetSourceVariant(e){if(Object.prototype.hasOwnProperty.call(e,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(e,this.defaultLayout.property))return;const t=this.registry[e[this.discriminator.property]];if(t&&(!t.layout||t.property&&Object.prototype.hasOwnProperty.call(e,t.property)))return t}else for(const t in this.registry){const n=this.registry[t];if(n.property&&Object.prototype.hasOwnProperty.call(e,n.property))return n}throw new Error("unable to infer src variant")}decode(e,t=0){let n;const r=this.discriminator,s=r.decode(e,t),i=this.registry[s];if(i===void 0){const a=this.defaultLayout;let c=0;this.usesPrefixDiscriminator&&(c=r.layout.span),n=this.makeDestinationObject(),n[r.property]=s,n[a.property]=a.decode(e,t+c)}else n=i.decode(e,t);return n}encode(e,t,n=0){const r=this.getSourceVariant(e);if(r===void 0){const s=this.discriminator,i=this.defaultLayout;let a=0;return this.usesPrefixDiscriminator&&(a=s.layout.span),s.encode(e[s.property],t,n),a+i.encode(e[i.property],t,n+a)}return r.encode(e,t,n)}addVariant(e,t,n){const r=new qs(this,e,t,n);return this.registry[e]=r,r}getVariant(e,t=0){let n;return e instanceof Uint8Array?n=this.discriminator.decode(e,t):n=e,this.registry[n]}}h.Union=or;class qs extends Y{constructor(e,t,n,r){if(!(e instanceof or))throw new TypeError("union must be a Union");if(!Number.isInteger(t)||0>t)throw new TypeError("variant must be a (non-negative) integer");if(typeof n=="string"&&r===void 0&&(r=n,n=null),n){if(!(n instanceof Y))throw new TypeError("layout must be a Layout");if(e.defaultLayout!==null&&0<=n.span&&n.span>e.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof r!="string")throw new TypeError("variant must have a String property")}let s=e.span;0>e.span&&(s=n?n.span:0,0<=s&&e.usesPrefixDiscriminator&&(s+=e.discriminator.layout.span)),super(s,r),this.union=e,this.variant=t,this.layout=n||null}getSpan(e,t=0){if(0<=this.span)return this.span;let n=0;this.union.usesPrefixDiscriminator&&(n=this.union.discriminator.layout.span);let r=0;return this.layout&&(r=this.layout.getSpan(e,t+n)),n+r}decode(e,t=0){const n=this.makeDestinationObject();if(this!==this.union.getVariant(e,t))throw new Error("variant mismatch");let r=0;return this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span),this.layout?n[this.property]=this.layout.decode(e,t+r):this.property?n[this.property]=!0:this.union.usesPrefixDiscriminator&&(n[this.union.discriminator.property]=this.variant),n}encode(e,t,n=0){let r=0;if(this.union.usesPrefixDiscriminator&&(r=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(e,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,t,n);let s=r;if(this.layout&&(this.layout.encode(e[this.property],t,n+r),s+=this.layout.getSpan(t,n+r),0<=this.union.span&&s>this.union.span))throw new Error("encoded variant overruns containing union");return s}fromArray(e){if(this.layout)return this.layout.fromArray(e)}}h.VariantLayout=qs;function xt(o){return 0>o&&(o+=4294967296),o}class ir extends Y{constructor(e,t,n){if(!(e instanceof Ue||e instanceof Ke))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof t=="string"&&n===void 0&&(n=t,t=!1),4<e.span)throw new RangeError("word cannot exceed 32 bits");super(e.span,n),this.word=e,this.msb=!!t,this.fields=[];let r=0;this._packedSetValue=function(s){return r=xt(s),this},this._packedGetValue=function(){return r}}decode(e,t=0){const n=this.makeDestinationObject(),r=this.word.decode(e,t);this._packedSetValue(r);for(const s of this.fields)s.property!==void 0&&(n[s.property]=s.decode(e));return n}encode(e,t,n=0){const r=this.word.decode(t,n);this._packedSetValue(r);for(const s of this.fields)if(s.property!==void 0){const i=e[s.property];i!==void 0&&s.encode(i)}return this.word.encode(this._packedGetValue(),t,n)}addField(e,t){const n=new ar(this,e,t);return this.fields.push(n),n}addBoolean(e){const t=new Hs(this,e);return this.fields.push(t),t}fieldFor(e){if(typeof e!="string")throw new TypeError("property must be string");for(const t of this.fields)if(t.property===e)return t}}h.BitStructure=ir;class ar{constructor(e,t,n){if(!(e instanceof ir))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(t)||0>=t)throw new TypeError("bits must be positive integer");const r=8*e.span,s=e.fields.reduce((i,a)=>i+a.bits,0);if(t+s>r)throw new Error("bits too long for span remainder ("+(r-s)+" of "+r+" remain)");this.container=e,this.bits=t,this.valueMask=(1<<t)-1,t===32&&(this.valueMask=4294967295),this.start=s,this.container.msb&&(this.start=r-s-t),this.wordMask=xt(this.valueMask<<this.start),this.property=n}decode(e,t){const n=this.container._packedGetValue();return xt(n&this.wordMask)>>>this.start}encode(e){if(typeof e!="number"||!Number.isInteger(e)||e!==xt(e&this.valueMask))throw new TypeError(nr("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const t=this.container._packedGetValue(),n=xt(e<<this.start);this.container._packedSetValue(xt(t&~this.wordMask)|n)}}h.BitField=ar;let Hs=class extends ar{constructor(e,t){super(e,1,t)}decode(e,t){return!!super.decode(e,t)}encode(e){typeof e=="boolean"&&(e=+e),super.encode(e)}};h.Boolean=Hs;class $s extends Y{constructor(e,t){if(!(e instanceof Be&&e.isCount()||Number.isInteger(e)&&0<=e))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let n=-1;e instanceof Be||(n=e),super(n,t),this.length=e}getSpan(e,t){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),n}decode(e,t=0){let n=this.span;return 0>n&&(n=this.length.decode(e,t)),$(e).slice(t,t+n)}encode(e,t,n){let r=this.length;if(this.length instanceof Be&&(r=e.length),!(e instanceof Uint8Array&&r===e.length))throw new TypeError(nr("Blob.encode",this)+" requires (length "+r+") Uint8Array as src");if(n+r>t.length)throw new RangeError("encoding overruns Uint8Array");const s=$(e);return $(t).write(s.toString("hex"),n,r,"hex"),this.length instanceof Be&&this.length.encode(r,t,n),r}}h.Blob=$s;class Vs extends Y{constructor(e){super(-1,e)}getSpan(e,t=0){Lt(e);let n=t;for(;n<e.length&&e[n]!==0;)n+=1;return 1+n-t}decode(e,t=0){const n=this.getSpan(e,t);return $(e).slice(t,t+n-1).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));const r=tr.Buffer.from(e,"utf8"),s=r.length;if(n+s>t.length)throw new RangeError("encoding overruns Buffer");const i=$(t);return r.copy(i,n),i[n+s]=0,s+1}}h.CString=Vs;class js extends Y{constructor(e,t){if(typeof e=="string"&&t===void 0&&(t=e,e=void 0),e===void 0)e=-1;else if(!Number.isInteger(e))throw new TypeError("maxSpan must be an integer");super(-1,t),this.maxSpan=e}getSpan(e,t=0){return Lt(e),e.length-t}decode(e,t=0){const n=this.getSpan(e,t);if(0<=this.maxSpan&&this.maxSpan<n)throw new RangeError("text length exceeds maxSpan");return $(e).slice(t,t+n).toString("utf-8")}encode(e,t,n=0){typeof e!="string"&&(e=String(e));const r=tr.Buffer.from(e,"utf8"),s=r.length;if(0<=this.maxSpan&&this.maxSpan<s)throw new RangeError("text length exceeds maxSpan");if(n+s>t.length)throw new RangeError("encoding overruns Buffer");return r.copy($(t),n),s}}h.UTF8=js;class Gs extends Y{constructor(e,t){super(0,t),this.value=e}decode(e,t){return this.value}encode(e,t,n){return 0}}h.Constant=Gs;h.greedy=(o,e)=>new Ls(o,e);var dt=h.offset=(o,e,t)=>new rr(o,e,t),M=h.u8=o=>new Ue(1,o),ze=h.u16=o=>new Ue(2,o);h.u24=o=>new Ue(3,o);var R=h.u32=o=>new Ue(4,o);h.u40=o=>new Ue(5,o);h.u48=o=>new Ue(6,o);var de=h.nu64=o=>new Cs(o);h.u16be=o=>new Ke(2,o);h.u24be=o=>new Ke(3,o);h.u32be=o=>new Ke(4,o);h.u40be=o=>new Ke(5,o);h.u48be=o=>new Ke(6,o);h.nu64be=o=>new Os(o);h.s8=o=>new kt(1,o);h.s16=o=>new kt(2,o);h.s24=o=>new kt(3,o);h.s32=o=>new kt(4,o);h.s40=o=>new kt(5,o);h.s48=o=>new kt(6,o);var Pe=h.ns64=o=>new zs(o);h.s16be=o=>new Ct(2,o);h.s24be=o=>new Ct(3,o);h.s32be=o=>new Ct(4,o);h.s40be=o=>new Ct(5,o);h.s48be=o=>new Ct(6,o);h.ns64be=o=>new Us(o);h.f32=o=>new Ns(o);h.f32be=o=>new Ks(o);h.f64=o=>new Ws(o);h.f64be=o=>new Fs(o);var B=h.struct=(o,e,t)=>new Ms(o,e,t);h.bits=(o,e,t)=>new ir(o,e,t);var ge=h.seq=(o,e,t)=>new Ds(o,e,t);h.union=(o,e,t)=>new or(o,e,t);h.unionLayoutDiscriminator=(o,e)=>new cn(o,e);var ne=h.blob=(o,e)=>new $s(o,e);h.cstr=o=>new Vs(o);h.utf8=(o,e)=>new js(o,e);h.constant=(o,e)=>new Gs(o,e);var Vt={};Object.defineProperty(Vt,"__esModule",{value:!0});function ca(o){{const e=Buffer.from(o);e.reverse();const t=e.toString("hex");return t.length===0?BigInt(0):BigInt(`0x${t}`)}}var ua=Vt.toBigIntLE=ca;function la(o){{const e=o.toString("hex");return e.length===0?BigInt(0):BigInt(`0x${e}`)}}Vt.toBigIntBE=la;function da(o,e){{const t=o.toString(16),n=Buffer.from(t.padStart(e*2,"0").slice(0,e*2),"hex");return n.reverse(),n}}var Ys=Vt.toBufferLE=da;function ha(o,e){{const t=o.toString(16);return Buffer.from(t.padStart(e*2,"0").slice(0,e*2),"hex")}}Vt.toBufferBE=ha;class fa extends TypeError{constructor(e,t){let n;const{message:r,explanation:s,...i}=e,{path:a}=e,c=a.length===0?r:`At path: ${a.join(".")} -- ${r}`;super(s??c),s!=null&&(this.cause=c),Object.assign(this,i),this.name=this.constructor.name,this.failures=()=>n??(n=[e,...t()])}}function pa(o){return jt(o)&&typeof o[Symbol.iterator]=="function"}function jt(o){return typeof o=="object"&&o!=null}function un(o){return jt(o)&&!Array.isArray(o)}function We(o){return typeof o=="symbol"?o.toString():typeof o=="string"?JSON.stringify(o):`${o}`}function ya(o){const{done:e,value:t}=o.next();return e?void 0:t}function ga(o,e,t,n){if(o===!0)return;o===!1?o={}:typeof o=="string"&&(o={message:o});const{path:r,branch:s}=e,{type:i}=t,{refinement:a,message:c=`Expected a value of type \`${i}\`${a?` with refinement \`${a}\``:""}, but received: \`${We(n)}\``}=o;return{value:n,type:i,refinement:a,key:r[r.length-1],path:r,branch:s,...o,message:c}}function*Mr(o,e,t,n){pa(o)||(o=[o]);for(const r of o){const s=ga(r,e,t,n);s&&(yield s)}}function*cr(o,e,t={}){const{path:n=[],branch:r=[o],coerce:s=!1,mask:i=!1}=t,a={path:n,branch:r,mask:i};s&&(o=e.coercer(o,a));let c="valid";for(const l of e.validator(o,a))l.explanation=t.message,c="not_valid",yield[l,void 0];for(let[l,u,p]of e.entries(o,a)){const b=cr(u,p,{path:l===void 0?n:[...n,l],branch:l===void 0?r:[...r,u],coerce:s,mask:i,message:t.message});for(const f of b)f[0]?(c=f[0].refinement!=null?"not_refined":"not_valid",yield[f[0],void 0]):s&&(u=f[1],l===void 0?o=u:o instanceof Map?o.set(l,u):o instanceof Set?o.add(u):jt(o)&&(u!==void 0||l in o)&&(o[l]=u))}if(c!=="not_valid")for(const l of e.refiner(o,a))l.explanation=t.message,c="not_refined",yield[l,void 0];c==="valid"&&(yield[void 0,o])}let Xe=class{constructor(e){const{type:t,schema:n,validator:r,refiner:s,coercer:i=c=>c,entries:a=function*(){}}=e;this.type=t,this.schema=n,this.entries=a,this.coercer=i,r?this.validator=(c,l)=>{const u=r(c,l);return Mr(u,l,this,c)}:this.validator=()=>[],s?this.refiner=(c,l)=>{const u=s(c,l);return Mr(u,l,this,c)}:this.refiner=()=>[]}assert(e,t){return Js(e,this,t)}create(e,t){return S(e,this,t)}is(e){return Xs(e,this)}mask(e,t){return ba(e,this,t)}validate(e,t={}){return Gt(e,this,t)}};function Js(o,e,t){const n=Gt(o,e,{message:t});if(n[0])throw n[0]}function S(o,e,t){const n=Gt(o,e,{coerce:!0,message:t});if(n[0])throw n[0];return n[1]}function ba(o,e,t){const n=Gt(o,e,{coerce:!0,mask:!0,message:t});if(n[0])throw n[0];return n[1]}function Xs(o,e){return!Gt(o,e)[0]}function Gt(o,e,t={}){const n=cr(o,e,t),r=ya(n);return r[0]?[new fa(r[0],function*(){for(const i of n)i[0]&&(yield i[0])}),void 0]:[void 0,r[1]]}function wt(o,e){return new Xe({type:o,schema:null,validator:e})}function ma(){return wt("any",()=>!0)}function _(o){return new Xe({type:"array",schema:o,*entries(e){if(o&&Array.isArray(e))for(const[t,n]of e.entries())yield[t,n,o]},coercer(e){return Array.isArray(e)?e.slice():e},validator(e){return Array.isArray(e)||`Expected an array value, but received: ${We(e)}`}})}function je(){return wt("boolean",o=>typeof o=="boolean")}function ur(o){return wt("instance",e=>e instanceof o||`Expected a \`${o.name}\` instance, but received: ${We(e)}`)}function re(o){const e=We(o),t=typeof o;return new Xe({type:"literal",schema:t==="string"||t==="number"||t==="boolean"?o:null,validator(n){return n===o||`Expected the literal \`${e}\`, but received: ${We(n)}`}})}function ka(){return wt("never",()=>!1)}function E(o){return new Xe({...o,validator:(e,t)=>e===null||o.validator(e,t),refiner:(e,t)=>e===null||o.refiner(e,t)})}function d(){return wt("number",o=>typeof o=="number"&&!isNaN(o)||`Expected a number, but received: ${We(o)}`)}function L(o){return new Xe({...o,validator:(e,t)=>e===void 0||o.validator(e,t),refiner:(e,t)=>e===void 0||o.refiner(e,t)})}function Zs(o,e){return new Xe({type:"record",schema:null,*entries(t){if(jt(t))for(const n in t){const r=t[n];yield[n,n,o],yield[n,r,e]}},validator(t){return un(t)||`Expected an object, but received: ${We(t)}`},coercer(t){return un(t)?{...t}:t}})}function k(){return wt("string",o=>typeof o=="string"||`Expected a string, but received: ${We(o)}`)}function lr(o){const e=ka();return new Xe({type:"tuple",schema:null,*entries(t){if(Array.isArray(t)){const n=Math.max(o.length,t.length);for(let r=0;r<n;r++)yield[r,t[r],o[r]||e]}},validator(t){return Array.isArray(t)||`Expected an array, but received: ${We(t)}`},coercer(t){return Array.isArray(t)?t.slice():t}})}function g(o){const e=Object.keys(o);return new Xe({type:"type",schema:o,*entries(t){if(jt(t))for(const n of e)yield[n,t[n],o[n]]},validator(t){return un(t)||`Expected an object, but received: ${We(t)}`},coercer(t){return un(t)?{...t}:t}})}function Ie(o){const e=o.map(t=>t.type).join(" | ");return new Xe({type:"union",schema:null,coercer(t,n){for(const r of o){const[s,i]=r.validate(t,{coerce:!0,mask:n.mask});if(!s)return i}return t},validator(t,n){const r=[];for(const s of o){const[...i]=cr(t,s,n),[a]=i;if(a[0])for(const[c]of i)c&&r.push(c);else return[]}return[`Expected the value to satisfy a union of \`${e}\`, but received: ${We(t)}`,...r]}})}function Ot(){return wt("unknown",()=>!0)}function Yt(o,e,t){return new Xe({...o,coercer:(n,r)=>Xs(n,e)?o.coercer(t(n,r),r):o.coercer(n,r)})}var en,wa=new Uint8Array(16);function Qs(){if(!en&&(en=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||typeof msCrypto<"u"&&typeof msCrypto.getRandomValues=="function"&&msCrypto.getRandomValues.bind(msCrypto),!en))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return en(wa)}const Sa=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;function mn(o){return typeof o=="string"&&Sa.test(o)}var le=[];for(var Ln=0;Ln<256;++Ln)le.push((Ln+256).toString(16).substr(1));function kn(o){var e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,t=(le[o[e+0]]+le[o[e+1]]+le[o[e+2]]+le[o[e+3]]+"-"+le[o[e+4]]+le[o[e+5]]+"-"+le[o[e+6]]+le[o[e+7]]+"-"+le[o[e+8]]+le[o[e+9]]+"-"+le[o[e+10]]+le[o[e+11]]+le[o[e+12]]+le[o[e+13]]+le[o[e+14]]+le[o[e+15]]).toLowerCase();if(!mn(t))throw TypeError("Stringified UUID is invalid");return t}var qr,Cn,On=0,zn=0;function Ia(o,e,t){var n=e&&t||0,r=e||new Array(16);o=o||{};var s=o.node||qr,i=o.clockseq!==void 0?o.clockseq:Cn;if(s==null||i==null){var a=o.random||(o.rng||Qs)();s==null&&(s=qr=[a[0]|1,a[1],a[2],a[3],a[4],a[5]]),i==null&&(i=Cn=(a[6]<<8|a[7])&16383)}var c=o.msecs!==void 0?o.msecs:Date.now(),l=o.nsecs!==void 0?o.nsecs:zn+1,u=c-On+(l-zn)/1e4;if(u<0&&o.clockseq===void 0&&(i=i+1&16383),(u<0||c>On)&&o.nsecs===void 0&&(l=0),l>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");On=c,zn=l,Cn=i,c+=122192928e5;var p=((c&268435455)*1e4+l)%4294967296;r[n++]=p>>>24&255,r[n++]=p>>>16&255,r[n++]=p>>>8&255,r[n++]=p&255;var b=c/4294967296*1e4&268435455;r[n++]=b>>>8&255,r[n++]=b&255,r[n++]=b>>>24&15|16,r[n++]=b>>>16&255,r[n++]=i>>>8|128,r[n++]=i&255;for(var f=0;f<6;++f)r[n+f]=s[f];return e||kn(r)}function eo(o){if(!mn(o))throw TypeError("Invalid UUID");var e,t=new Uint8Array(16);return t[0]=(e=parseInt(o.slice(0,8),16))>>>24,t[1]=e>>>16&255,t[2]=e>>>8&255,t[3]=e&255,t[4]=(e=parseInt(o.slice(9,13),16))>>>8,t[5]=e&255,t[6]=(e=parseInt(o.slice(14,18),16))>>>8,t[7]=e&255,t[8]=(e=parseInt(o.slice(19,23),16))>>>8,t[9]=e&255,t[10]=(e=parseInt(o.slice(24,36),16))/1099511627776&255,t[11]=e/4294967296&255,t[12]=e>>>24&255,t[13]=e>>>16&255,t[14]=e>>>8&255,t[15]=e&255,t}function Aa(o){o=unescape(encodeURIComponent(o));for(var e=[],t=0;t<o.length;++t)e.push(o.charCodeAt(t));return e}var _a="6ba7b810-9dad-11d1-80b4-00c04fd430c8",Ea="6ba7b811-9dad-11d1-80b4-00c04fd430c8";function to(o,e,t){function n(r,s,i,a){if(typeof r=="string"&&(r=Aa(r)),typeof s=="string"&&(s=eo(s)),s.length!==16)throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");var c=new Uint8Array(16+r.length);if(c.set(s),c.set(r,s.length),c=t(c),c[6]=c[6]&15|e,c[8]=c[8]&63|128,i){a=a||0;for(var l=0;l<16;++l)i[a+l]=c[l];return i}return kn(c)}try{n.name=o}catch{}return n.DNS=_a,n.URL=Ea,n}function xa(o){if(typeof o=="string"){var e=unescape(encodeURIComponent(o));o=new Uint8Array(e.length);for(var t=0;t<e.length;++t)o[t]=e.charCodeAt(t)}return Ra(Ba(va(o),o.length*8))}function Ra(o){for(var e=[],t=o.length*32,n="0123456789abcdef",r=0;r<t;r+=8){var s=o[r>>5]>>>r%32&255,i=parseInt(n.charAt(s>>>4&15)+n.charAt(s&15),16);e.push(i)}return e}function no(o){return(o+64>>>9<<4)+14+1}function Ba(o,e){o[e>>5]|=128<<e%32,o[no(e)-1]=e;for(var t=1732584193,n=-271733879,r=-1732584194,s=271733878,i=0;i<o.length;i+=16){var a=t,c=n,l=r,u=s;t=be(t,n,r,s,o[i],7,-680876936),s=be(s,t,n,r,o[i+1],12,-389564586),r=be(r,s,t,n,o[i+2],17,606105819),n=be(n,r,s,t,o[i+3],22,-1044525330),t=be(t,n,r,s,o[i+4],7,-176418897),s=be(s,t,n,r,o[i+5],12,1200080426),r=be(r,s,t,n,o[i+6],17,-1473231341),n=be(n,r,s,t,o[i+7],22,-45705983),t=be(t,n,r,s,o[i+8],7,1770035416),s=be(s,t,n,r,o[i+9],12,-1958414417),r=be(r,s,t,n,o[i+10],17,-42063),n=be(n,r,s,t,o[i+11],22,-1990404162),t=be(t,n,r,s,o[i+12],7,1804603682),s=be(s,t,n,r,o[i+13],12,-40341101),r=be(r,s,t,n,o[i+14],17,-1502002290),n=be(n,r,s,t,o[i+15],22,1236535329),t=me(t,n,r,s,o[i+1],5,-165796510),s=me(s,t,n,r,o[i+6],9,-1069501632),r=me(r,s,t,n,o[i+11],14,643717713),n=me(n,r,s,t,o[i],20,-373897302),t=me(t,n,r,s,o[i+5],5,-701558691),s=me(s,t,n,r,o[i+10],9,38016083),r=me(r,s,t,n,o[i+15],14,-660478335),n=me(n,r,s,t,o[i+4],20,-405537848),t=me(t,n,r,s,o[i+9],5,568446438),s=me(s,t,n,r,o[i+14],9,-1019803690),r=me(r,s,t,n,o[i+3],14,-187363961),n=me(n,r,s,t,o[i+8],20,1163531501),t=me(t,n,r,s,o[i+13],5,-1444681467),s=me(s,t,n,r,o[i+2],9,-51403784),r=me(r,s,t,n,o[i+7],14,1735328473),n=me(n,r,s,t,o[i+12],20,-1926607734),t=ke(t,n,r,s,o[i+5],4,-378558),s=ke(s,t,n,r,o[i+8],11,-2022574463),r=ke(r,s,t,n,o[i+11],16,1839030562),n=ke(n,r,s,t,o[i+14],23,-35309556),t=ke(t,n,r,s,o[i+1],4,-1530992060),s=ke(s,t,n,r,o[i+4],11,1272893353),r=ke(r,s,t,n,o[i+7],16,-155497632),n=ke(n,r,s,t,o[i+10],23,-1094730640),t=ke(t,n,r,s,o[i+13],4,681279174),s=ke(s,t,n,r,o[i],11,-358537222),r=ke(r,s,t,n,o[i+3],16,-722521979),n=ke(n,r,s,t,o[i+6],23,76029189),t=ke(t,n,r,s,o[i+9],4,-640364487),s=ke(s,t,n,r,o[i+12],11,-421815835),r=ke(r,s,t,n,o[i+15],16,530742520),n=ke(n,r,s,t,o[i+2],23,-995338651),t=we(t,n,r,s,o[i],6,-198630844),s=we(s,t,n,r,o[i+7],10,1126891415),r=we(r,s,t,n,o[i+14],15,-1416354905),n=we(n,r,s,t,o[i+5],21,-57434055),t=we(t,n,r,s,o[i+12],6,1700485571),s=we(s,t,n,r,o[i+3],10,-1894986606),r=we(r,s,t,n,o[i+10],15,-1051523),n=we(n,r,s,t,o[i+1],21,-2054922799),t=we(t,n,r,s,o[i+8],6,1873313359),s=we(s,t,n,r,o[i+15],10,-30611744),r=we(r,s,t,n,o[i+6],15,-1560198380),n=we(n,r,s,t,o[i+13],21,1309151649),t=we(t,n,r,s,o[i+4],6,-145523070),s=we(s,t,n,r,o[i+11],10,-1120210379),r=we(r,s,t,n,o[i+2],15,718787259),n=we(n,r,s,t,o[i+9],21,-343485551),t=lt(t,a),n=lt(n,c),r=lt(r,l),s=lt(s,u)}return[t,n,r,s]}function va(o){if(o.length===0)return[];for(var e=o.length*8,t=new Uint32Array(no(e)),n=0;n<e;n+=8)t[n>>5]|=(o[n/8]&255)<<n%32;return t}function lt(o,e){var t=(o&65535)+(e&65535),n=(o>>16)+(e>>16)+(t>>16);return n<<16|t&65535}function Pa(o,e){return o<<e|o>>>32-e}function wn(o,e,t,n,r,s){return lt(Pa(lt(lt(e,o),lt(n,s)),r),t)}function be(o,e,t,n,r,s,i){return wn(e&t|~e&n,o,e,r,s,i)}function me(o,e,t,n,r,s,i){return wn(e&n|t&~n,o,e,r,s,i)}function ke(o,e,t,n,r,s,i){return wn(e^t^n,o,e,r,s,i)}function we(o,e,t,n,r,s,i){return wn(t^(e|~n),o,e,r,s,i)}var Ta=to("v3",48,xa);const La=Ta;function Ca(o,e,t){o=o||{};var n=o.random||(o.rng||Qs)();if(n[6]=n[6]&15|64,n[8]=n[8]&63|128,e){t=t||0;for(var r=0;r<16;++r)e[t+r]=n[r];return e}return kn(n)}function Oa(o,e,t,n){switch(o){case 0:return e&t^~e&n;case 1:return e^t^n;case 2:return e&t^e&n^t&n;case 3:return e^t^n}}function Un(o,e){return o<<e|o>>>32-e}function za(o){var e=[1518500249,1859775393,2400959708,3395469782],t=[1732584193,4023233417,2562383102,271733878,3285377520];if(typeof o=="string"){var n=unescape(encodeURIComponent(o));o=[];for(var r=0;r<n.length;++r)o.push(n.charCodeAt(r))}else Array.isArray(o)||(o=Array.prototype.slice.call(o));o.push(128);for(var s=o.length/4+2,i=Math.ceil(s/16),a=new Array(i),c=0;c<i;++c){for(var l=new Uint32Array(16),u=0;u<16;++u)l[u]=o[c*64+u*4]<<24|o[c*64+u*4+1]<<16|o[c*64+u*4+2]<<8|o[c*64+u*4+3];a[c]=l}a[i-1][14]=(o.length-1)*8/Math.pow(2,32),a[i-1][14]=Math.floor(a[i-1][14]),a[i-1][15]=(o.length-1)*8&4294967295;for(var p=0;p<i;++p){for(var b=new Uint32Array(80),f=0;f<16;++f)b[f]=a[p][f];for(var m=16;m<80;++m)b[m]=Un(b[m-3]^b[m-8]^b[m-14]^b[m-16],1);for(var y=t[0],w=t[1],P=t[2],F=t[3],x=t[4],J=0;J<80;++J){var ve=Math.floor(J/20),Fe=Un(y,5)+Oa(ve,w,P,F)+x+e[ve]+b[J]>>>0;x=F,F=P,P=Un(w,30)>>>0,w=y,y=Fe}t[0]=t[0]+y>>>0,t[1]=t[1]+w>>>0,t[2]=t[2]+P>>>0,t[3]=t[3]+F>>>0,t[4]=t[4]+x>>>0}return[t[0]>>24&255,t[0]>>16&255,t[0]>>8&255,t[0]&255,t[1]>>24&255,t[1]>>16&255,t[1]>>8&255,t[1]&255,t[2]>>24&255,t[2]>>16&255,t[2]>>8&255,t[2]&255,t[3]>>24&255,t[3]>>16&255,t[3]>>8&255,t[3]&255,t[4]>>24&255,t[4]>>16&255,t[4]>>8&255,t[4]&255]}var Ua=to("v5",80,za);const Na=Ua,Ka="00000000-0000-0000-0000-000000000000";function Wa(o){if(!mn(o))throw TypeError("Invalid UUID");return parseInt(o.substr(14,1),16)}const Fa=Object.freeze(Object.defineProperty({__proto__:null,NIL:Ka,parse:eo,stringify:kn,v1:Ia,v3:La,v4:Ca,v5:Na,validate:mn,version:Wa},Symbol.toStringTag,{value:"Module"})),ro=fs(Fa),Da=ro.v4,Ma=function(o,e,t,n){if(typeof o!="string")throw new TypeError(o+" must be a string");n=n||{};const r=typeof n.version=="number"?n.version:2;if(r!==1&&r!==2)throw new TypeError(r+" must be 1 or 2");const s={method:o};if(r===2&&(s.jsonrpc="2.0"),e){if(typeof e!="object"&&!Array.isArray(e))throw new TypeError(e+" must be an object, array or omitted");s.params=e}if(typeof t>"u"){const i=typeof n.generator=="function"?n.generator:function(){return Da()};s.id=i(s,n)}else r===2&&t===null?n.notificationIdNull&&(s.id=null):s.id=t;return s};var qa=Ma;const Ha=ro.v4,$a=qa,qt=function(o,e){if(!(this instanceof qt))return new qt(o,e);e||(e={}),this.options={reviver:typeof e.reviver<"u"?e.reviver:null,replacer:typeof e.replacer<"u"?e.replacer:null,generator:typeof e.generator<"u"?e.generator:function(){return Ha()},version:typeof e.version<"u"?e.version:2,notificationIdNull:typeof e.notificationIdNull=="boolean"?e.notificationIdNull:!1},this.callServer=o};var Va=qt;qt.prototype.request=function(o,e,t,n){const r=this;let s=null;const i=Array.isArray(o)&&typeof e=="function";if(this.options.version===1&&i)throw new TypeError("JSON-RPC 1.0 does not support batching");if(i||!i&&o&&typeof o=="object"&&typeof e=="function")n=e,s=o;else{typeof t=="function"&&(n=t,t=void 0);const l=typeof n=="function";try{s=$a(o,e,t,{generator:this.options.generator,version:this.options.version,notificationIdNull:this.options.notificationIdNull})}catch(u){if(l)return n(u);throw u}if(!l)return s}let c;try{c=JSON.stringify(s,this.options.replacer)}catch(l){return n(l)}return this.callServer(c,function(l,u){r._parseResponse(l,u,n)}),s};qt.prototype._parseResponse=function(o,e,t){if(o){t(o);return}if(!e)return t();let n;try{n=JSON.parse(e,this.options.reviver)}catch(r){return t(r)}if(t.length===3)if(Array.isArray(n)){const r=function(i){return typeof i.error<"u"},s=function(i){return!r(i)};return t(null,n.filter(r),n.filter(s))}else return t(null,n.error,n.result);t(null,n)};const ja=ni(Va);var Ga=class extends ps{constructor(e,t,n){super();ce(this,"socket");this.socket=new window.WebSocket(e,n),this.socket.onopen=()=>this.emit("open"),this.socket.onmessage=r=>this.emit("message",r.data),this.socket.onerror=r=>this.emit("error",r),this.socket.onclose=r=>{this.emit("close",r.code,r.reason)}}send(e,t,n){const r=n||t;try{this.socket.send(e),r()}catch(s){r(s)}}close(e,t){this.socket.close(e,t)}addEventListener(e,t,n){this.socket.addEventListener(e,t,n)}};function Ya(o,e){return new Ga(o,e)}var Ja=class{encode(o){return JSON.stringify(o)}decode(o){return JSON.parse(o)}},Xa=class extends ps{constructor(e,t="ws://localhost:8080",{autoconnect:n=!0,reconnect:r=!0,reconnect_interval:s=1e3,max_reconnects:i=5,...a}={},c,l){super();ce(this,"address");ce(this,"rpc_id");ce(this,"queue");ce(this,"options");ce(this,"autoconnect");ce(this,"ready");ce(this,"reconnect");ce(this,"reconnect_timer_id");ce(this,"reconnect_interval");ce(this,"max_reconnects");ce(this,"rest_options");ce(this,"current_reconnects");ce(this,"generate_request_id");ce(this,"socket");ce(this,"webSocketFactory");ce(this,"dataPack");this.webSocketFactory=e,this.queue={},this.rpc_id=0,this.address=t,this.autoconnect=n,this.ready=!1,this.reconnect=r,this.reconnect_timer_id=void 0,this.reconnect_interval=s,this.max_reconnects=i,this.rest_options=a,this.current_reconnects=0,this.generate_request_id=c||(()=>++this.rpc_id),l?this.dataPack=l:this.dataPack=new Ja,this.autoconnect&&this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}connect(){this.socket||this._connect(this.address,{autoconnect:this.autoconnect,reconnect:this.reconnect,reconnect_interval:this.reconnect_interval,max_reconnects:this.max_reconnects,...this.rest_options})}call(e,t,n,r){return!r&&typeof n=="object"&&(r=n,n=null),new Promise((s,i)=>{if(!this.ready)return i(new Error("socket not ready"));const a=this.generate_request_id(e,t),c={jsonrpc:"2.0",method:e,params:t||void 0,id:a};this.socket.send(this.dataPack.encode(c),r,l=>{if(l)return i(l);this.queue[a]={promise:[s,i]},n&&(this.queue[a].timeout=setTimeout(()=>{delete this.queue[a],i(new Error("reply timeout"))},n))})})}async login(e){const t=await this.call("rpc.login",e);if(!t)throw new Error("authentication failed");return t}async listMethods(){return await this.call("__listMethods")}notify(e,t){return new Promise((n,r)=>{if(!this.ready)return r(new Error("socket not ready"));const s={jsonrpc:"2.0",method:e,params:t};this.socket.send(this.dataPack.encode(s),i=>{if(i)return r(i);n()})})}async subscribe(e){typeof e=="string"&&(e=[e]);const t=await this.call("rpc.on",e);if(typeof e=="string"&&t[e]!=="ok")throw new Error("Failed subscribing to an event '"+e+"' with: "+t[e]);return t}async unsubscribe(e){typeof e=="string"&&(e=[e]);const t=await this.call("rpc.off",e);if(typeof e=="string"&&t[e]!=="ok")throw new Error("Failed unsubscribing from an event with: "+t);return t}close(e,t){this.socket.close(e||1e3,t)}setAutoReconnect(e){this.reconnect=e}setReconnectInterval(e){this.reconnect_interval=e}setMaxReconnects(e){this.max_reconnects=e}_connect(e,t){clearTimeout(this.reconnect_timer_id),this.socket=this.webSocketFactory(e,t),this.socket.addEventListener("open",()=>{this.ready=!0,this.emit("open"),this.current_reconnects=0}),this.socket.addEventListener("message",({data:n})=>{n instanceof ArrayBuffer&&(n=T.Buffer.from(n).toString());try{n=this.dataPack.decode(n)}catch{return}if(n.notification&&this.listeners(n.notification).length){if(!Object.keys(n.params).length)return this.emit(n.notification);const r=[n.notification];if(n.params.constructor===Object)r.push(n.params);else for(let s=0;s<n.params.length;s++)r.push(n.params[s]);return Promise.resolve().then(()=>{this.emit.apply(this,r)})}if(!this.queue[n.id])return n.method?Promise.resolve().then(()=>{this.emit(n.method,n==null?void 0:n.params)}):void 0;"error"in n=="result"in n&&this.queue[n.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),this.queue[n.id].timeout&&clearTimeout(this.queue[n.id].timeout),n.error?this.queue[n.id].promise[1](n.error):this.queue[n.id].promise[0](n.result),delete this.queue[n.id]}),this.socket.addEventListener("error",n=>this.emit("error",n)),this.socket.addEventListener("close",({code:n,reason:r})=>{this.ready&&setTimeout(()=>this.emit("close",n,r),0),this.ready=!1,this.socket=void 0,n!==1e3&&(this.current_reconnects++,this.reconnect&&(this.max_reconnects>this.current_reconnects||this.max_reconnects===0)&&(this.reconnect_timer_id=setTimeout(()=>this._connect(e,t),this.reconnect_interval)))})}};const Za=Tt.utils.randomPrivateKey,Hr=()=>{const o=Tt.utils.randomPrivateKey(),e=ln(o),t=new Uint8Array(64);return t.set(o),t.set(e,32),{publicKey:e,secretKey:t}},ln=Tt.getPublicKey;function $r(o){try{return Tt.ExtendedPoint.fromHex(o),!0}catch{return!1}}const dr=(o,e)=>Tt.sign(o,e.slice(0,32)),Qa=Tt.verify,K=o=>T.Buffer.isBuffer(o)?o:o instanceof Uint8Array?T.Buffer.from(o.buffer,o.byteOffset,o.byteLength):T.Buffer.from(o);class so{constructor(e){Object.assign(this,e)}encode(){return T.Buffer.from(Ps(nn,this))}static decode(e){return Ts(nn,this,e)}static decodeUnchecked(e){return Es(nn,this,e)}}class ol extends so{constructor(e){if(super(e),this.enum="",Object.keys(e).length!==1)throw new Error("Enum can only take single value");Object.keys(e).map(t=>{this.enum=t})}}const nn=new Map;var oo;const ec=32,rt=32;function tc(o){return o._bn!==void 0}let Vr=1;class I extends so{constructor(e){if(super({}),this._bn=void 0,tc(e))this._bn=e._bn;else{if(typeof e=="string"){const t=pe.decode(e);if(t.length!=rt)throw new Error("Invalid public key input");this._bn=new zr(t)}else this._bn=new zr(e);if(this._bn.byteLength()>rt)throw new Error("Invalid public key input")}}static unique(){const e=new I(Vr);return Vr+=1,new I(e.toBuffer())}equals(e){return this._bn.eq(e._bn)}toBase58(){return pe.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const e=this.toBuffer();return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}toBuffer(){const e=this._bn.toArrayLike(T.Buffer);if(e.length===rt)return e;const t=T.Buffer.alloc(32);return e.copy(t,32-e.length),t}get[Symbol.toStringTag](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(e,t,n){const r=T.Buffer.concat([e.toBuffer(),T.Buffer.from(t),n.toBuffer()]),s=Ur(r);return new I(s)}static createProgramAddressSync(e,t){let n=T.Buffer.alloc(0);e.forEach(function(s){if(s.length>ec)throw new TypeError("Max seed length exceeded");n=T.Buffer.concat([n,K(s)])}),n=T.Buffer.concat([n,t.toBuffer(),T.Buffer.from("ProgramDerivedAddress")]);const r=Ur(n);if($r(r))throw new Error("Invalid seeds, address must fall off the curve");return new I(r)}static async createProgramAddress(e,t){return this.createProgramAddressSync(e,t)}static findProgramAddressSync(e,t){let n=255,r;for(;n!=0;){try{const s=e.concat(T.Buffer.from([n]));r=this.createProgramAddressSync(s,t)}catch(s){if(s instanceof TypeError)throw s;n--;continue}return[r,n]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(e,t){return this.findProgramAddressSync(e,t)}static isOnCurve(e){const t=new I(e);return $r(t.toBytes())}}oo=I;I.default=new oo("11111111111111111111111111111111");nn.set(I,{kind:"struct",fields:[["_bn","u256"]]});class il{constructor(e){if(this._publicKey=void 0,this._secretKey=void 0,e){const t=K(e);if(e.length!==64)throw new Error("bad secret key size");this._publicKey=t.slice(32,64),this._secretKey=t.slice(0,32)}else this._secretKey=K(Za()),this._publicKey=K(ln(this._secretKey))}get publicKey(){return new I(this._publicKey)}get secretKey(){return T.Buffer.concat([this._secretKey,this._publicKey],64)}}const al=new I("BPFLoader1111111111111111111111111111111111"),mt=1232,hr=127,dn=64;class io extends Error{constructor(e){super(`Signature ${e} has expired: block height exceeded.`),this.signature=void 0,this.signature=e}}Object.defineProperty(io.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class ao extends Error{constructor(e,t){super(`Transaction was not confirmed in ${t.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${e} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=e}}Object.defineProperty(ao.prototype,"name",{value:"TransactionExpiredTimeoutError"});class Ft extends Error{constructor(e){super(`Signature ${e} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=e}}Object.defineProperty(Ft.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class hn{constructor(e,t){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=e,this.accountKeysFromLookups=t}keySegments(){const e=[this.staticAccountKeys];return this.accountKeysFromLookups&&(e.push(this.accountKeysFromLookups.writable),e.push(this.accountKeysFromLookups.readonly)),e}get(e){for(const t of this.keySegments()){if(e<t.length)return t[e];e-=t.length}}get length(){return this.keySegments().flat().length}compileInstructions(e){if(this.length>256)throw new Error("Account index overflow encountered during compilation");const n=new Map;this.keySegments().flat().forEach((s,i)=>{n.set(s.toBase58(),i)});const r=s=>{const i=n.get(s.toBase58());if(i===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return i};return e.map(s=>({programIdIndex:r(s.programId),accountKeyIndexes:s.keys.map(i=>r(i.pubkey)),data:s.data}))}}const W=(o="publicKey")=>ne(32,o),nc=(o="signature")=>ne(64,o),bt=(o="string")=>{const e=B([R("length"),R("lengthPadding"),ne(dt(R(),-8),"chars")],o),t=e.decode.bind(e),n=e.encode.bind(e),r=e;return r.decode=(s,i)=>t(s,i).chars.toString(),r.encode=(s,i,a)=>{const c={chars:T.Buffer.from(s,"utf8")};return n(c,i,a)},r.alloc=s=>R().span+R().span+T.Buffer.from(s,"utf8").length,r},rc=(o="authorized")=>B([W("staker"),W("withdrawer")],o),sc=(o="lockup")=>B([Pe("unixTimestamp"),Pe("epoch"),W("custodian")],o),oc=(o="voteInit")=>B([W("nodePubkey"),W("authorizedVoter"),W("authorizedWithdrawer"),M("commission")],o),ic=(o="voteAuthorizeWithSeedArgs")=>B([R("voteAuthorizationType"),W("currentAuthorityDerivedKeyOwnerPubkey"),bt("currentAuthorityDerivedKeySeed"),W("newAuthorized")],o);function co(o,e){const t=r=>{if(r.span>=0)return r.span;if(typeof r.alloc=="function")return r.alloc(e[r.property]);if("count"in r&&"elementLayout"in r){const s=e[r.property];if(Array.isArray(s))return s.length*t(r.elementLayout)}else if("fields"in r)return co({layout:r},e[r.property]);return 0};let n=0;return o.layout.fields.forEach(r=>{n+=t(r)}),n}function xe(o){let e=0,t=0;for(;;){let n=o.shift();if(e|=(n&127)<<t*7,t+=1,!(n&128))break}return e}function Te(o,e){let t=e;for(;;){let n=t&127;if(t>>=7,t==0){o.push(n);break}else n|=128,o.push(n)}}function H(o,e){if(!o)throw new Error(e||"Assertion failed")}class Sn{constructor(e,t){this.payer=void 0,this.keyMetaMap=void 0,this.payer=e,this.keyMetaMap=t}static compile(e,t){const n=new Map,r=i=>{const a=i.toBase58();let c=n.get(a);return c===void 0&&(c={isSigner:!1,isWritable:!1,isInvoked:!1},n.set(a,c)),c},s=r(t);s.isSigner=!0,s.isWritable=!0;for(const i of e){r(i.programId).isInvoked=!0;for(const a of i.keys){const c=r(a.pubkey);c.isSigner||(c.isSigner=a.isSigner),c.isWritable||(c.isWritable=a.isWritable)}}return new Sn(t,n)}getMessageComponents(){const e=[...this.keyMetaMap.entries()];H(e.length<=256,"Max static account keys length exceeded");const t=e.filter(([,c])=>c.isSigner&&c.isWritable),n=e.filter(([,c])=>c.isSigner&&!c.isWritable),r=e.filter(([,c])=>!c.isSigner&&c.isWritable),s=e.filter(([,c])=>!c.isSigner&&!c.isWritable),i={numRequiredSignatures:t.length+n.length,numReadonlySignedAccounts:n.length,numReadonlyUnsignedAccounts:s.length};{H(t.length>0,"Expected at least one writable signer key");const[c]=t[0];H(c===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const a=[...t.map(([c])=>new I(c)),...n.map(([c])=>new I(c)),...r.map(([c])=>new I(c)),...s.map(([c])=>new I(c))];return[i,a]}extractTableLookup(e){const[t,n]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&i.isWritable),[r,s]=this.drainKeysFoundInLookupTable(e.state.addresses,i=>!i.isSigner&&!i.isInvoked&&!i.isWritable);if(!(t.length===0&&r.length===0))return[{accountKey:e.key,writableIndexes:t,readonlyIndexes:r},{writable:n,readonly:s}]}drainKeysFoundInLookupTable(e,t){const n=new Array,r=new Array;for(const[s,i]of this.keyMetaMap.entries())if(t(i)){const a=new I(s),c=e.findIndex(l=>l.equals(a));c>=0&&(H(c<256,"Max lookup table index exceeded"),n.push(c),r.push(a),this.keyMetaMap.delete(s))}return[n,r]}}const uo="Reached end of buffer unexpectedly";function He(o){if(o.length===0)throw new Error(uo);return o.shift()}function Re(o,...e){const[t]=e;if(e.length===2?t+(e[1]??0)>o.length:t>=o.length)throw new Error(uo);return o.splice(...e)}class Ge{constructor(e){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=e.header,this.accountKeys=e.accountKeys.map(t=>new I(t)),this.recentBlockhash=e.recentBlockhash,this.instructions=e.instructions,this.instructions.forEach(t=>this.indexToProgramIds.set(t.programIdIndex,this.accountKeys[t.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(e=>({programIdIndex:e.programIdIndex,accountKeyIndexes:e.accounts,data:pe.decode(e.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new hn(this.staticAccountKeys)}static compile(e){const t=Sn.compile(e.instructions,e.payerKey),[n,r]=t.getMessageComponents(),i=new hn(r).compileInstructions(e.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:pe.encode(a.data)}));return new Ge({header:n,accountKeys:r,recentBlockhash:e.recentBlockhash,instructions:i})}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures;if(e>=this.header.numRequiredSignatures){const n=e-t,s=this.accountKeys.length-t-this.header.numReadonlyUnsignedAccounts;return n<s}else{const n=t-this.header.numReadonlySignedAccounts;return e<n}}isProgramId(e){return this.indexToProgramIds.has(e)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((e,t)=>!this.isProgramId(t))}serialize(){const e=this.accountKeys.length;let t=[];Te(t,e);const n=this.instructions.map(p=>{const{accounts:b,programIdIndex:f}=p,m=Array.from(pe.decode(p.data));let y=[];Te(y,b.length);let w=[];return Te(w,m.length),{programIdIndex:f,keyIndicesCount:T.Buffer.from(y),keyIndices:b,dataLength:T.Buffer.from(w),data:m}});let r=[];Te(r,n.length);let s=T.Buffer.alloc(mt);T.Buffer.from(r).copy(s);let i=r.length;n.forEach(p=>{const f=B([M("programIdIndex"),ne(p.keyIndicesCount.length,"keyIndicesCount"),ge(M("keyIndex"),p.keyIndices.length,"keyIndices"),ne(p.dataLength.length,"dataLength"),ge(M("userdatum"),p.data.length,"data")]).encode(p,s,i);i+=f}),s=s.slice(0,i);const a=B([ne(1,"numRequiredSignatures"),ne(1,"numReadonlySignedAccounts"),ne(1,"numReadonlyUnsignedAccounts"),ne(t.length,"keyCount"),ge(W("key"),e,"keys"),W("recentBlockhash")]),c={numRequiredSignatures:T.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:T.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:T.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:T.Buffer.from(t),keys:this.accountKeys.map(p=>K(p.toBytes())),recentBlockhash:pe.decode(this.recentBlockhash)};let l=T.Buffer.alloc(2048);const u=a.encode(c,l);return s.copy(l,u),l.slice(0,u+s.length)}static from(e){let t=[...e];const n=He(t);if(n!==(n&hr))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const r=He(t),s=He(t),i=xe(t);let a=[];for(let b=0;b<i;b++){const f=Re(t,0,rt);a.push(new I(T.Buffer.from(f)))}const c=Re(t,0,rt),l=xe(t);let u=[];for(let b=0;b<l;b++){const f=He(t),m=xe(t),y=Re(t,0,m),w=xe(t),P=Re(t,0,w),F=pe.encode(T.Buffer.from(P));u.push({programIdIndex:f,accounts:y,data:F})}const p={header:{numRequiredSignatures:n,numReadonlySignedAccounts:r,numReadonlyUnsignedAccounts:s},recentBlockhash:pe.encode(T.Buffer.from(c)),accountKeys:a,instructions:u};return new Ge(p)}}class Bt{constructor(e){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=e.header,this.staticAccountKeys=e.staticAccountKeys,this.recentBlockhash=e.recentBlockhash,this.compiledInstructions=e.compiledInstructions,this.addressTableLookups=e.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let e=0;for(const t of this.addressTableLookups)e+=t.readonlyIndexes.length+t.writableIndexes.length;return e}getAccountKeys(e){let t;if(e&&"accountKeysFromLookups"in e&&e.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=e.accountKeysFromLookups.writable.length+e.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");t=e.accountKeysFromLookups}else if(e&&"addressLookupTableAccounts"in e&&e.addressLookupTableAccounts)t=this.resolveAddressTableLookups(e.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new hn(this.staticAccountKeys,t)}isAccountSigner(e){return e<this.header.numRequiredSignatures}isAccountWritable(e){const t=this.header.numRequiredSignatures,n=this.staticAccountKeys.length;if(e>=n){const r=e-n,s=this.addressTableLookups.reduce((i,a)=>i+a.writableIndexes.length,0);return r<s}else if(e>=this.header.numRequiredSignatures){const r=e-t,i=n-t-this.header.numReadonlyUnsignedAccounts;return r<i}else{const r=t-this.header.numReadonlySignedAccounts;return e<r}}resolveAddressTableLookups(e){const t={writable:[],readonly:[]};for(const n of this.addressTableLookups){const r=e.find(s=>s.key.equals(n.accountKey));if(!r)throw new Error(`Failed to find address lookup table account for table key ${n.accountKey.toBase58()}`);for(const s of n.writableIndexes)if(s<r.state.addresses.length)t.writable.push(r.state.addresses[s]);else throw new Error(`Failed to find address for index ${s} in address lookup table ${n.accountKey.toBase58()}`);for(const s of n.readonlyIndexes)if(s<r.state.addresses.length)t.readonly.push(r.state.addresses[s]);else throw new Error(`Failed to find address for index ${s} in address lookup table ${n.accountKey.toBase58()}`)}return t}static compile(e){const t=Sn.compile(e.instructions,e.payerKey),n=new Array,r={writable:new Array,readonly:new Array},s=e.addressLookupTableAccounts||[];for(const u of s){const p=t.extractTableLookup(u);if(p!==void 0){const[b,{writable:f,readonly:m}]=p;n.push(b),r.writable.push(...f),r.readonly.push(...m)}}const[i,a]=t.getMessageComponents(),l=new hn(a,r).compileInstructions(e.instructions);return new Bt({header:i,staticAccountKeys:a,recentBlockhash:e.recentBlockhash,compiledInstructions:l,addressTableLookups:n})}serialize(){const e=Array();Te(e,this.staticAccountKeys.length);const t=this.serializeInstructions(),n=Array();Te(n,this.compiledInstructions.length);const r=this.serializeAddressTableLookups(),s=Array();Te(s,this.addressTableLookups.length);const i=B([M("prefix"),B([M("numRequiredSignatures"),M("numReadonlySignedAccounts"),M("numReadonlyUnsignedAccounts")],"header"),ne(e.length,"staticAccountKeysLength"),ge(W(),this.staticAccountKeys.length,"staticAccountKeys"),W("recentBlockhash"),ne(n.length,"instructionsLength"),ne(t.length,"serializedInstructions"),ne(s.length,"addressTableLookupsLength"),ne(r.length,"serializedAddressTableLookups")]),a=new Uint8Array(mt),l=i.encode({prefix:128,header:this.header,staticAccountKeysLength:new Uint8Array(e),staticAccountKeys:this.staticAccountKeys.map(u=>u.toBytes()),recentBlockhash:pe.decode(this.recentBlockhash),instructionsLength:new Uint8Array(n),serializedInstructions:t,addressTableLookupsLength:new Uint8Array(s),serializedAddressTableLookups:r},a);return a.slice(0,l)}serializeInstructions(){let e=0;const t=new Uint8Array(mt);for(const n of this.compiledInstructions){const r=Array();Te(r,n.accountKeyIndexes.length);const s=Array();Te(s,n.data.length);const i=B([M("programIdIndex"),ne(r.length,"encodedAccountKeyIndexesLength"),ge(M(),n.accountKeyIndexes.length,"accountKeyIndexes"),ne(s.length,"encodedDataLength"),ne(n.data.length,"data")]);e+=i.encode({programIdIndex:n.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(r),accountKeyIndexes:n.accountKeyIndexes,encodedDataLength:new Uint8Array(s),data:n.data},t,e)}return t.slice(0,e)}serializeAddressTableLookups(){let e=0;const t=new Uint8Array(mt);for(const n of this.addressTableLookups){const r=Array();Te(r,n.writableIndexes.length);const s=Array();Te(s,n.readonlyIndexes.length);const i=B([W("accountKey"),ne(r.length,"encodedWritableIndexesLength"),ge(M(),n.writableIndexes.length,"writableIndexes"),ne(s.length,"encodedReadonlyIndexesLength"),ge(M(),n.readonlyIndexes.length,"readonlyIndexes")]);e+=i.encode({accountKey:n.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(r),writableIndexes:n.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(s),readonlyIndexes:n.readonlyIndexes},t,e)}return t.slice(0,e)}static deserialize(e){let t=[...e];const n=He(t),r=n&hr;H(n!==r,"Expected versioned message but received legacy message");const s=r;H(s===0,`Expected versioned message with version 0 but found version ${s}`);const i={numRequiredSignatures:He(t),numReadonlySignedAccounts:He(t),numReadonlyUnsignedAccounts:He(t)},a=[],c=xe(t);for(let m=0;m<c;m++)a.push(new I(Re(t,0,rt)));const l=pe.encode(Re(t,0,rt)),u=xe(t),p=[];for(let m=0;m<u;m++){const y=He(t),w=xe(t),P=Re(t,0,w),F=xe(t),x=new Uint8Array(Re(t,0,F));p.push({programIdIndex:y,accountKeyIndexes:P,data:x})}const b=xe(t),f=[];for(let m=0;m<b;m++){const y=new I(Re(t,0,rt)),w=xe(t),P=Re(t,0,w),F=xe(t),x=Re(t,0,F);f.push({accountKey:y,writableIndexes:P,readonlyIndexes:x})}return new Bt({header:i,staticAccountKeys:a,recentBlockhash:l,compiledInstructions:p,addressTableLookups:f})}}const lo={deserializeMessageVersion(o){const e=o[0],t=e&hr;return t===e?"legacy":t},deserialize:o=>{const e=lo.deserializeMessageVersion(o);if(e==="legacy")return Ge.from(o);if(e===0)return Bt.deserialize(o);throw new Error(`Transaction message version ${e} deserialization is not supported`)}};let at=function(o){return o[o.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",o[o.PROCESSED=1]="PROCESSED",o[o.TIMED_OUT=2]="TIMED_OUT",o[o.NONCE_INVALID=3]="NONCE_INVALID",o}({});const ac=T.Buffer.alloc(dn).fill(0);class ee{constructor(e){this.keys=void 0,this.programId=void 0,this.data=T.Buffer.alloc(0),this.programId=e.programId,this.keys=e.keys,e.data&&(this.data=e.data)}toJSON(){return{keys:this.keys.map(({pubkey:e,isSigner:t,isWritable:n})=>({pubkey:e.toJSON(),isSigner:t,isWritable:n})),programId:this.programId.toJSON(),data:[...this.data]}}}class G{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(e){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!e)if(e.feePayer&&(this.feePayer=e.feePayer),e.signatures&&(this.signatures=e.signatures),Object.prototype.hasOwnProperty.call(e,"nonceInfo")){const{minContextSlot:t,nonceInfo:n}=e;this.minNonceContextSlot=t,this.nonceInfo=n}else if(Object.prototype.hasOwnProperty.call(e,"lastValidBlockHeight")){const{blockhash:t,lastValidBlockHeight:n}=e;this.recentBlockhash=t,this.lastValidBlockHeight=n}else{const{recentBlockhash:t,nonceInfo:n}=e;n&&(this.nonceInfo=n),this.recentBlockhash=t}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(e=>e.toJSON()),signers:this.signatures.map(({publicKey:e})=>e.toJSON())}}add(...e){if(e.length===0)throw new Error("No instructions");return e.forEach(t=>{"instructions"in t?this.instructions=this.instructions.concat(t.instructions):"data"in t&&"programId"in t&&"keys"in t?this.instructions.push(t):this.instructions.push(new ee(t))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let e,t;if(this.nonceInfo?(e=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?t=[this.nonceInfo.nonceInstruction,...this.instructions]:t=this.instructions):(e=this.recentBlockhash,t=this.instructions),!e)throw new Error("Transaction recentBlockhash required");t.length<1&&console.warn("No instructions provided");let n;if(this.feePayer)n=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)n=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let y=0;y<t.length;y++)if(t[y].programId===void 0)throw new Error(`Transaction instruction index ${y} has undefined program id`);const r=[],s=[];t.forEach(y=>{y.keys.forEach(P=>{s.push({...P})});const w=y.programId.toString();r.includes(w)||r.push(w)}),r.forEach(y=>{s.push({pubkey:new I(y),isSigner:!1,isWritable:!1})});const i=[];s.forEach(y=>{const w=y.pubkey.toString(),P=i.findIndex(F=>F.pubkey.toString()===w);P>-1?(i[P].isWritable=i[P].isWritable||y.isWritable,i[P].isSigner=i[P].isSigner||y.isSigner):i.push(y)}),i.sort(function(y,w){if(y.isSigner!==w.isSigner)return y.isSigner?-1:1;if(y.isWritable!==w.isWritable)return y.isWritable?-1:1;const P={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return y.pubkey.toBase58().localeCompare(w.pubkey.toBase58(),"en",P)});const a=i.findIndex(y=>y.pubkey.equals(n));if(a>-1){const[y]=i.splice(a,1);y.isSigner=!0,y.isWritable=!0,i.unshift(y)}else i.unshift({pubkey:n,isSigner:!0,isWritable:!0});for(const y of this.signatures){const w=i.findIndex(P=>P.pubkey.equals(y.publicKey));if(w>-1)i[w].isSigner||(i[w].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${y.publicKey.toString()}`)}let c=0,l=0,u=0;const p=[],b=[];i.forEach(({pubkey:y,isSigner:w,isWritable:P})=>{w?(p.push(y.toString()),c+=1,P||(l+=1)):(b.push(y.toString()),P||(u+=1))});const f=p.concat(b),m=t.map(y=>{const{data:w,programId:P}=y;return{programIdIndex:f.indexOf(P.toString()),accounts:y.keys.map(F=>f.indexOf(F.pubkey.toString())),data:pe.encode(w)}});return m.forEach(y=>{H(y.programIdIndex>=0),y.accounts.forEach(w=>H(w>=0))}),new Ge({header:{numRequiredSignatures:c,numReadonlySignedAccounts:l,numReadonlyUnsignedAccounts:u},accountKeys:f,recentBlockhash:e,instructions:m})}_compile(){const e=this.compileMessage(),t=e.accountKeys.slice(0,e.header.numRequiredSignatures);return this.signatures.length===t.length&&this.signatures.every((r,s)=>t[s].equals(r.publicKey))||(this.signatures=t.map(n=>({signature:null,publicKey:n}))),e}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(e){return(await e.getFeeForMessage(this.compileMessage())).value}setSigners(...e){if(e.length===0)throw new Error("No signers");const t=new Set;this.signatures=e.filter(n=>{const r=n.toString();return t.has(r)?!1:(t.add(r),!0)}).map(n=>({signature:null,publicKey:n}))}sign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const s of e){const i=s.publicKey.toString();t.has(i)||(t.add(i),n.push(s))}this.signatures=n.map(s=>({signature:null,publicKey:s.publicKey}));const r=this._compile();this._partialSign(r,...n)}partialSign(...e){if(e.length===0)throw new Error("No signers");const t=new Set,n=[];for(const s of e){const i=s.publicKey.toString();t.has(i)||(t.add(i),n.push(s))}const r=this._compile();this._partialSign(r,...n)}_partialSign(e,...t){const n=e.serialize();t.forEach(r=>{const s=dr(n,r.secretKey);this._addSignature(r.publicKey,K(s))})}addSignature(e,t){this._compile(),this._addSignature(e,t)}_addSignature(e,t){H(t.length===64);const n=this.signatures.findIndex(r=>e.equals(r.publicKey));if(n<0)throw new Error(`unknown signer: ${e.toString()}`);this.signatures[n].signature=T.Buffer.from(t)}verifySignatures(e=!0){return!this._getMessageSignednessErrors(this.serializeMessage(),e)}_getMessageSignednessErrors(e,t){const n={};for(const{signature:r,publicKey:s}of this.signatures)r===null?t&&(n.missing||(n.missing=[])).push(s):Qa(r,e,s.toBytes())||(n.invalid||(n.invalid=[])).push(s);return n.invalid||n.missing?n:void 0}serialize(e){const{requireAllSignatures:t,verifySignatures:n}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},e),r=this.serializeMessage();if(n){const s=this._getMessageSignednessErrors(r,t);if(s){let i="Signature verification failed.";throw s.invalid&&(i+=`
Invalid signature for public key${s.invalid.length===1?"":"(s)"} [\`${s.invalid.map(a=>a.toBase58()).join("`, `")}\`].`),s.missing&&(i+=`
Missing signature for public key${s.missing.length===1?"":"(s)"} [\`${s.missing.map(a=>a.toBase58()).join("`, `")}\`].`),new Error(i)}}return this._serialize(r)}_serialize(e){const{signatures:t}=this,n=[];Te(n,t.length);const r=n.length+t.length*64+e.length,s=T.Buffer.alloc(r);return H(t.length<256),T.Buffer.from(n).copy(s,0),t.forEach(({signature:i},a)=>{i!==null&&(H(i.length===64,"signature has invalid length"),T.Buffer.from(i).copy(s,n.length+a*64))}),e.copy(s,n.length+t.length*64),H(s.length<=mt,`Transaction too large: ${s.length} > ${mt}`),s}get keys(){return H(this.instructions.length===1),this.instructions[0].keys.map(e=>e.pubkey)}get programId(){return H(this.instructions.length===1),this.instructions[0].programId}get data(){return H(this.instructions.length===1),this.instructions[0].data}static from(e){let t=[...e];const n=xe(t);let r=[];for(let s=0;s<n;s++){const i=Re(t,0,dn);r.push(pe.encode(T.Buffer.from(i)))}return G.populate(Ge.from(t),r)}static populate(e,t=[]){const n=new G;return n.recentBlockhash=e.recentBlockhash,e.header.numRequiredSignatures>0&&(n.feePayer=e.accountKeys[0]),t.forEach((r,s)=>{const i={signature:r==pe.encode(ac)?null:pe.decode(r),publicKey:e.accountKeys[s]};n.signatures.push(i)}),e.instructions.forEach(r=>{const s=r.accounts.map(i=>{const a=e.accountKeys[i];return{pubkey:a,isSigner:n.signatures.some(c=>c.publicKey.toString()===a.toString())||e.isAccountSigner(i),isWritable:e.isAccountWritable(i)}});n.instructions.push(new ee({keys:s,programId:e.accountKeys[r.programIdIndex],data:pe.decode(r.data)}))}),n._message=e,n._json=n.toJSON(),n}}class ho{constructor(e){this.payerKey=void 0,this.instructions=void 0,this.recentBlockhash=void 0,this.payerKey=e.payerKey,this.instructions=e.instructions,this.recentBlockhash=e.recentBlockhash}static decompile(e,t){const{header:n,compiledInstructions:r,recentBlockhash:s}=e,{numRequiredSignatures:i,numReadonlySignedAccounts:a,numReadonlyUnsignedAccounts:c}=n,l=i-a;H(l>0,"Message header is invalid");const u=e.staticAccountKeys.length-i-c;H(u>=0,"Message header is invalid");const p=e.getAccountKeys(t),b=p.get(0);if(b===void 0)throw new Error("Failed to decompile message because no account keys were found");const f=[];for(const m of r){const y=[];for(const P of m.accountKeyIndexes){const F=p.get(P);if(F===void 0)throw new Error(`Failed to find key for account key index ${P}`);const x=P<i;let J;x?J=P<l:P<p.staticAccountKeys.length?J=P-i<u:J=P-p.staticAccountKeys.length<p.accountKeysFromLookups.writable.length,y.push({pubkey:F,isSigner:P<n.numRequiredSignatures,isWritable:J})}const w=p.get(m.programIdIndex);if(w===void 0)throw new Error(`Failed to find program id for program id index ${m.programIdIndex}`);f.push(new ee({programId:w,data:K(m.data),keys:y}))}return new ho({payerKey:b,instructions:f,recentBlockhash:s})}compileToLegacyMessage(){return Ge.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions})}compileToV0Message(e){return Bt.compile({payerKey:this.payerKey,recentBlockhash:this.recentBlockhash,instructions:this.instructions,addressLookupTableAccounts:e})}}class fo{get version(){return this.message.version}constructor(e,t){if(this.signatures=void 0,this.message=void 0,t!==void 0)H(t.length===e.header.numRequiredSignatures,"Expected signatures length to be equal to the number of required signatures"),this.signatures=t;else{const n=[];for(let r=0;r<e.header.numRequiredSignatures;r++)n.push(new Uint8Array(dn));this.signatures=n}this.message=e}serialize(){const e=this.message.serialize(),t=Array();Te(t,this.signatures.length);const n=B([ne(t.length,"encodedSignaturesLength"),ge(nc(),this.signatures.length,"signatures"),ne(e.length,"serializedMessage")]),r=new Uint8Array(2048),s=n.encode({encodedSignaturesLength:new Uint8Array(t),signatures:this.signatures,serializedMessage:e},r);return r.slice(0,s)}static deserialize(e){let t=[...e];const n=[],r=xe(t);for(let i=0;i<r;i++)n.push(new Uint8Array(Re(t,0,dn)));const s=lo.deserialize(new Uint8Array(t));return new fo(s,n)}sign(e){const t=this.message.serialize(),n=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures);for(const r of e){const s=n.findIndex(i=>i.equals(r.publicKey));H(s>=0,`Cannot sign with non signer key ${r.publicKey.toBase58()}`),this.signatures[s]=dr(t,r.secretKey)}}addSignature(e,t){H(t.byteLength===64,"Signature must be 64 bytes long");const r=this.message.staticAccountKeys.slice(0,this.message.header.numRequiredSignatures).findIndex(s=>s.equals(e));H(r>=0,`Can not add signature; \`${e.toBase58()}\` is not required to sign this transaction`),this.signatures[r]=t}}const cc=160,uc=64,lc=cc/uc,po=1e3/lc,et=new I("SysvarC1ock11111111111111111111111111111111"),cl=new I("SysvarEpochSchedu1e111111111111111111111111"),ul=new I("Sysvar1nstructions1111111111111111111111111"),Nn=new I("SysvarRecentB1ockHashes11111111111111111111"),Ht=new I("SysvarRent111111111111111111111111111111111"),ll=new I("SysvarRewards111111111111111111111111111111"),dl=new I("SysvarS1otHashes111111111111111111111111111"),hl=new I("SysvarS1otHistory11111111111111111111111111"),Kn=new I("SysvarStakeHistory1111111111111111111111111");class fn extends Error{constructor({action:e,signature:t,transactionMessage:n,logs:r}){const s=r?`Logs: 
${JSON.stringify(r.slice(-10),null,2)}. `:"",i="\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";let a;switch(e){case"send":a=`Transaction ${t} resulted in an error. 
${n}. `+s+i;break;case"simulate":a=`Simulation failed. 
Message: ${n}. 
`+s+i;break;default:a=`Unknown action '${(c=>c)(e)}'`}super(a),this.signature=void 0,this.transactionMessage=void 0,this.transactionLogs=void 0,this.signature=t,this.transactionMessage=n,this.transactionLogs=r||void 0}get transactionError(){return{message:this.transactionMessage,logs:Array.isArray(this.transactionLogs)?this.transactionLogs:void 0}}get logs(){const e=this.transactionLogs;if(!(e!=null&&typeof e=="object"&&"then"in e))return e}async getLogs(e){return Array.isArray(this.transactionLogs)||(this.transactionLogs=new Promise((t,n)=>{e.getTransaction(this.signature).then(r=>{if(r&&r.meta&&r.meta.logMessages){const s=r.meta.logMessages;this.transactionLogs=s,t(s)}else n(new Error("Log messages not found"))}).catch(n)})),await this.transactionLogs}}const fl={JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP:-32001,JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE:-32002,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE:-32003,JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE:-32004,JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY:-32005,JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:-32006,JSON_RPC_SERVER_ERROR_SLOT_SKIPPED:-32007,JSON_RPC_SERVER_ERROR_NO_SNAPSHOT:-32008,JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:-32009,JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:-32010,JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE:-32011,JSON_RPC_SCAN_ERROR:-32012,JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH:-32013,JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:-32014,JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:-32015,JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED:-32016};class v extends Error{constructor({code:e,message:t,data:n},r){super(r!=null?`${r}: ${t}`:t),this.code=void 0,this.data=void 0,this.code=e,this.data=n,this.name="SolanaJSONRPCError"}}async function jr(o,e,t,n){const r=n&&{skipPreflight:n.skipPreflight,preflightCommitment:n.preflightCommitment||n.commitment,maxRetries:n.maxRetries,minContextSlot:n.minContextSlot},s=await o.sendTransaction(e,t,r);let i;if(e.recentBlockhash!=null&&e.lastValidBlockHeight!=null)i=(await o.confirmTransaction({abortSignal:n==null?void 0:n.abortSignal,signature:s,blockhash:e.recentBlockhash,lastValidBlockHeight:e.lastValidBlockHeight},n&&n.commitment)).value;else if(e.minNonceContextSlot!=null&&e.nonceInfo!=null){const{nonceInstruction:a}=e.nonceInfo,c=a.keys[0].pubkey;i=(await o.confirmTransaction({abortSignal:n==null?void 0:n.abortSignal,minContextSlot:e.minNonceContextSlot,nonceAccountPubkey:c,nonceValue:e.nonceInfo.nonce,signature:s},n&&n.commitment)).value}else(n==null?void 0:n.abortSignal)!=null&&console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."),i=(await o.confirmTransaction(s,n&&n.commitment)).value;if(i.err)throw s!=null?new fn({action:"send",signature:s,transactionMessage:`Status: (${JSON.stringify(i)})`}):new Error(`Transaction ${s} failed (${JSON.stringify(i)})`);return s}function gt(o){return new Promise(e=>setTimeout(e,o))}function D(o,e){const t=o.layout.span>=0?o.layout.span:co(o,e),n=T.Buffer.alloc(t),r=Object.assign({instruction:o.index},e);return o.layout.encode(r,n),n}function j(o,e){let t;try{t=o.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.instruction!==o.index)throw new Error(`invalid instruction; instruction index mismatch ${t.instruction} != ${o.index}`);return t}const dc=de("lamportsPerSignature"),yo=B([R("version"),R("state"),W("authorizedPubkey"),W("nonce"),B([dc],"feeCalculator")]),Gr=yo.span;class fr{constructor(e){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=e.authorizedPubkey,this.nonce=e.nonce,this.feeCalculator=e.feeCalculator}static fromAccountData(e){const t=yo.decode(K(e),0);return new fr({authorizedPubkey:new I(t.authorizedPubkey),nonce:new I(t.nonce).toString(),feeCalculator:t.feeCalculator})}}const hc=o=>{const e=o.decode.bind(o),t=o.encode.bind(o);return{decode:e,encode:t}},fc=o=>e=>{const t=ne(o,e),{encode:n,decode:r}=hc(t),s=t;return s.decode=(i,a)=>{const c=r(i,a);return ua(T.Buffer.from(c))},s.encode=(i,a,c)=>{const l=Ys(i,o);return n(l,a,c)},s},vt=fc(8);class pl{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=R("instruction").decode(e.data);let r;for(const[s,i]of Object.entries(te))if(i.index==n){r=s;break}if(!r)throw new Error("Instruction type incorrect; not a SystemInstruction");return r}static decodeCreateAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t,space:n,programId:r}=j(te.Create,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,lamports:t,space:n,programId:new I(r)}}static decodeTransfer(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{lamports:t}=j(te.Transfer,e.data);return{fromPubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,lamports:t}}static decodeTransferWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t,seed:n,programId:r}=j(te.TransferWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,basePubkey:e.keys[1].pubkey,toPubkey:e.keys[2].pubkey,lamports:t,seed:n,programId:new I(r)}}static decodeAllocate(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{space:t}=j(te.Allocate,e.data);return{accountPubkey:e.keys[0].pubkey,space:t}}static decodeAllocateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:n,space:r,programId:s}=j(te.AllocateWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new I(t),seed:n,space:r,programId:new I(s)}}static decodeAssign(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{programId:t}=j(te.Assign,e.data);return{accountPubkey:e.keys[0].pubkey,programId:new I(t)}}static decodeAssignWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,1);const{base:t,seed:n,programId:r}=j(te.AssignWithSeed,e.data);return{accountPubkey:e.keys[0].pubkey,basePubkey:new I(t),seed:n,programId:new I(r)}}static decodeCreateWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{base:t,seed:n,lamports:r,space:s,programId:i}=j(te.CreateWithSeed,e.data);return{fromPubkey:e.keys[0].pubkey,newAccountPubkey:e.keys[1].pubkey,basePubkey:new I(t),seed:n,lamports:r,space:s,programId:new I(i)}}static decodeNonceInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{authorized:t}=j(te.InitializeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:new I(t)}}static decodeNonceAdvance(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),j(te.AdvanceNonceAccount,e.data),{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static decodeNonceWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=j(te.WithdrawNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t}}static decodeNonceAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t}=j(te.AuthorizeNonceAccount,e.data);return{noncePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[1].pubkey,newAuthorizedPubkey:new I(t)}}static checkProgramId(e){if(!e.equals(ye.programId))throw new Error("invalid instruction; programId is not SystemProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const te=Object.freeze({Create:{index:0,layout:B([R("instruction"),Pe("lamports"),Pe("space"),W("programId")])},Assign:{index:1,layout:B([R("instruction"),W("programId")])},Transfer:{index:2,layout:B([R("instruction"),vt("lamports")])},CreateWithSeed:{index:3,layout:B([R("instruction"),W("base"),bt("seed"),Pe("lamports"),Pe("space"),W("programId")])},AdvanceNonceAccount:{index:4,layout:B([R("instruction")])},WithdrawNonceAccount:{index:5,layout:B([R("instruction"),Pe("lamports")])},InitializeNonceAccount:{index:6,layout:B([R("instruction"),W("authorized")])},AuthorizeNonceAccount:{index:7,layout:B([R("instruction"),W("authorized")])},Allocate:{index:8,layout:B([R("instruction"),Pe("space")])},AllocateWithSeed:{index:9,layout:B([R("instruction"),W("base"),bt("seed"),Pe("space"),W("programId")])},AssignWithSeed:{index:10,layout:B([R("instruction"),W("base"),bt("seed"),W("programId")])},TransferWithSeed:{index:11,layout:B([R("instruction"),vt("lamports"),bt("seed"),W("programId")])},UpgradeNonceAccount:{index:12,layout:B([R("instruction")])}});class ye{constructor(){}static createAccount(e){const t=te.Create,n=D(t,{lamports:e.lamports,space:e.space,programId:K(e.programId.toBuffer())});return new ee({keys:[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!0,isWritable:!0}],programId:this.programId,data:n})}static transfer(e){let t,n;if("basePubkey"in e){const r=te.TransferWithSeed;t=D(r,{lamports:BigInt(e.lamports),seed:e.seed,programId:K(e.programId.toBuffer())}),n=[{pubkey:e.fromPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}else{const r=te.Transfer;t=D(r,{lamports:BigInt(e.lamports)}),n=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0}]}return new ee({keys:n,programId:this.programId,data:t})}static assign(e){let t,n;if("basePubkey"in e){const r=te.AssignWithSeed;t=D(r,{base:K(e.basePubkey.toBuffer()),seed:e.seed,programId:K(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const r=te.Assign;t=D(r,{programId:K(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new ee({keys:n,programId:this.programId,data:t})}static createAccountWithSeed(e){const t=te.CreateWithSeed,n=D(t,{base:K(e.basePubkey.toBuffer()),seed:e.seed,lamports:e.lamports,space:e.space,programId:K(e.programId.toBuffer())});let r=[{pubkey:e.fromPubkey,isSigner:!0,isWritable:!0},{pubkey:e.newAccountPubkey,isSigner:!1,isWritable:!0}];return e.basePubkey.equals(e.fromPubkey)||r.push({pubkey:e.basePubkey,isSigner:!0,isWritable:!1}),new ee({keys:r,programId:this.programId,data:n})}static createNonceAccount(e){const t=new G;"basePubkey"in e&&"seed"in e?t.add(ye.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:Gr,programId:this.programId})):t.add(ye.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.noncePubkey,lamports:e.lamports,space:Gr,programId:this.programId}));const n={noncePubkey:e.noncePubkey,authorizedPubkey:e.authorizedPubkey};return t.add(this.nonceInitialize(n)),t}static nonceInitialize(e){const t=te.InitializeNonceAccount,n=D(t,{authorized:K(e.authorizedPubkey.toBuffer())}),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Nn,isSigner:!1,isWritable:!1},{pubkey:Ht,isSigner:!1,isWritable:!1}],programId:this.programId,data:n};return new ee(r)}static nonceAdvance(e){const t=te.AdvanceNonceAccount,n=D(t),r={keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:Nn,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n};return new ee(r)}static nonceWithdraw(e){const t=te.WithdrawNonceAccount,n=D(t,{lamports:e.lamports});return new ee({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.toPubkey,isSigner:!1,isWritable:!0},{pubkey:Nn,isSigner:!1,isWritable:!1},{pubkey:Ht,isSigner:!1,isWritable:!1},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static nonceAuthorize(e){const t=te.AuthorizeNonceAccount,n=D(t,{authorized:K(e.newAuthorizedPubkey.toBuffer())});return new ee({keys:[{pubkey:e.noncePubkey,isSigner:!1,isWritable:!0},{pubkey:e.authorizedPubkey,isSigner:!0,isWritable:!1}],programId:this.programId,data:n})}static allocate(e){let t,n;if("basePubkey"in e){const r=te.AllocateWithSeed;t=D(r,{base:K(e.basePubkey.toBuffer()),seed:e.seed,space:e.space,programId:K(e.programId.toBuffer())}),n=[{pubkey:e.accountPubkey,isSigner:!1,isWritable:!0},{pubkey:e.basePubkey,isSigner:!0,isWritable:!1}]}else{const r=te.Allocate;t=D(r,{space:e.space}),n=[{pubkey:e.accountPubkey,isSigner:!0,isWritable:!0}]}return new ee({keys:n,programId:this.programId,data:t})}}ye.programId=new I("11111111111111111111111111111111");const pc=mt-300;class Pt{constructor(){}static getMinNumSignatures(e){return 2*(Math.ceil(e/Pt.chunkSize)+1+1)}static async load(e,t,n,r,s){{const p=await e.getMinimumBalanceForRentExemption(s.length),b=await e.getAccountInfo(n.publicKey,"confirmed");let f=null;if(b!==null){if(b.executable)return console.error("Program load failed, account is already executable"),!1;b.data.length!==s.length&&(f=f||new G,f.add(ye.allocate({accountPubkey:n.publicKey,space:s.length}))),b.owner.equals(r)||(f=f||new G,f.add(ye.assign({accountPubkey:n.publicKey,programId:r}))),b.lamports<p&&(f=f||new G,f.add(ye.transfer({fromPubkey:t.publicKey,toPubkey:n.publicKey,lamports:p-b.lamports})))}else f=new G().add(ye.createAccount({fromPubkey:t.publicKey,newAccountPubkey:n.publicKey,lamports:p>0?p:1,space:s.length,programId:r}));f!==null&&await jr(e,f,[t,n],{commitment:"confirmed"})}const i=B([R("instruction"),R("offset"),R("bytesLength"),R("bytesLengthPadding"),ge(M("byte"),dt(R(),-8),"bytes")]),a=Pt.chunkSize;let c=0,l=s,u=[];for(;l.length>0;){const p=l.slice(0,a),b=T.Buffer.alloc(a+16);i.encode({instruction:0,offset:c,bytes:p,bytesLength:0,bytesLengthPadding:0},b);const f=new G().add({keys:[{pubkey:n.publicKey,isSigner:!0,isWritable:!0}],programId:r,data:b});u.push(jr(e,f,[t,n],{commitment:"confirmed"})),e._rpcEndpoint.includes("solana.com")&&await gt(1e3/4),c+=a,l=l.slice(a)}await Promise.all(u);{const p=B([R("instruction")]),b=T.Buffer.alloc(p.span);p.encode({instruction:1},b);const f=new G().add({keys:[{pubkey:n.publicKey,isSigner:!0,isWritable:!0},{pubkey:Ht,isSigner:!1,isWritable:!1}],programId:r,data:b}),m="processed",y=await e.sendTransaction(f,[t,n],{preflightCommitment:m}),{context:w,value:P}=await e.confirmTransaction({signature:y,lastValidBlockHeight:f.lastValidBlockHeight,blockhash:f.recentBlockhash},m);if(P.err)throw new Error(`Transaction ${y} failed (${JSON.stringify(P)})`);for(;;){try{if(await e.getSlot({commitment:m})>w.slot)break}catch{}await new Promise(F=>setTimeout(F,Math.round(po/2)))}}return!0}}Pt.chunkSize=pc;const yl=new I("BPFLoader2111111111111111111111111111111111");class gl{static getMinNumSignatures(e){return Pt.getMinNumSignatures(e)}static load(e,t,n,r,s){return Pt.load(e,t,n,s,r)}}function yc(o){return o&&o.__esModule&&Object.prototype.hasOwnProperty.call(o,"default")?o.default:o}var Wn,Yr;function gc(){if(Yr)return Wn;Yr=1;var o=Object.prototype.toString,e=Object.keys||function(n){var r=[];for(var s in n)r.push(s);return r};function t(n,r){var s,i,a,c,l,u,p;if(n===!0)return"true";if(n===!1)return"false";switch(typeof n){case"object":if(n===null)return null;if(n.toJSON&&typeof n.toJSON=="function")return t(n.toJSON(),r);if(p=o.call(n),p==="[object Array]"){for(a="[",i=n.length-1,s=0;s<i;s++)a+=t(n[s],!0)+",";return i>-1&&(a+=t(n[s],!0)),a+"]"}else if(p==="[object Object]"){for(c=e(n).sort(),i=c.length,a="",s=0;s<i;)l=c[s],u=t(n[l],!1),u!==void 0&&(a&&(a+=","),a+=JSON.stringify(l)+":"+u),s++;return"{"+a+"}"}else return JSON.stringify(n);case"function":case"undefined":return r?null:void 0;case"string":return JSON.stringify(n);default:return isFinite(n)?n:null}}return Wn=function(n){var r=t(n,!1);if(r!==void 0)return""+r},Wn}var bc=gc(),Jr=yc(bc);const Wt=32;function Fn(o){let e=0;for(;o>1;)o/=2,e++;return e}function mc(o){return o===0?1:(o--,o|=o>>1,o|=o>>2,o|=o>>4,o|=o>>8,o|=o>>16,o|=o>>32,o+1)}class kc{constructor(e,t,n,r,s){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=e,this.leaderScheduleSlotOffset=t,this.warmup=n,this.firstNormalEpoch=r,this.firstNormalSlot=s}getEpoch(e){return this.getEpochAndSlotIndex(e)[0]}getEpochAndSlotIndex(e){if(e<this.firstNormalSlot){const t=Fn(mc(e+Wt+1))-Fn(Wt)-1,n=this.getSlotsInEpoch(t),r=e-(n-Wt);return[t,r]}else{const t=e-this.firstNormalSlot,n=Math.floor(t/this.slotsPerEpoch),r=this.firstNormalEpoch+n,s=t%this.slotsPerEpoch;return[r,s]}}getFirstSlotInEpoch(e){return e<=this.firstNormalEpoch?(Math.pow(2,e)-1)*Wt:(e-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(e){return this.getFirstSlotInEpoch(e)+this.getSlotsInEpoch(e)-1}getSlotsInEpoch(e){return e<this.firstNormalEpoch?Math.pow(2,e+Fn(Wt)):this.slotsPerEpoch}}var wc=globalThis.fetch;class Sc extends Xa{constructor(e,t,n){const r=s=>{const i=Ya(s,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...t});return"socket"in i?this.underlyingSocket=i.socket:this.underlyingSocket=i,i};super(r,e,t,n),this.underlyingSocket=void 0}call(...e){var n;const t=(n=this.underlyingSocket)==null?void 0:n.readyState;return t===1?super.call(...e):Promise.reject(new Error("Tried to call a JSON-RPC method `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}notify(...e){var n;const t=(n=this.underlyingSocket)==null?void 0:n.readyState;return t===1?super.notify(...e):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+e[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+t+")"))}}function Ic(o,e){let t;try{t=o.layout.decode(e)}catch(n){throw new Error("invalid instruction; "+n)}if(t.typeIndex!==o.index)throw new Error(`invalid account data; account type mismatch ${t.typeIndex} != ${o.index}`);return t}const Xr=56;class Zr{constructor(e){this.key=void 0,this.state=void 0,this.key=e.key,this.state=e.state}isActive(){const e=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===e}static deserialize(e){const t=Ic(Ac,e),n=e.length-Xr;H(n>=0,"lookup table is invalid"),H(n%32===0,"lookup table is invalid");const r=n/32,{addresses:s}=B([ge(W(),r,"addresses")]).decode(e.slice(Xr));return{deactivationSlot:t.deactivationSlot,lastExtendedSlot:t.lastExtendedSlot,lastExtendedSlotStartIndex:t.lastExtendedStartIndex,authority:t.authority.length!==0?new I(t.authority[0]):void 0,addresses:s.map(i=>new I(i))}}}const Ac={index:1,layout:B([R("typeIndex"),vt("deactivationSlot"),de("lastExtendedSlot"),M("lastExtendedStartIndex"),M(),ge(W(),dt(M(),-1),"authority")])},_c=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function Ec(o){const e=o.match(_c);if(e==null)throw TypeError(`Failed to validate endpoint URL \`${o}\``);const[t,n,r,s]=e,i=o.startsWith("https:")?"wss:":"ws:",a=r==null?null:parseInt(r.slice(1),10),c=a==null?"":`:${a+1}`;return`${i}//${n}${c}${s}`}const se=Yt(ur(I),k(),o=>new I(o)),go=lr([k(),re("base64")]),pr=Yt(ur(T.Buffer),go,o=>T.Buffer.from(o[0],"base64")),xc=30*1e3;function Rc(o){if(/^https?:/.test(o)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return o}function Q(o){let e,t;if(typeof o=="string")e=o;else if(o){const{commitment:n,...r}=o;e=n,t=r}return{commitment:e,config:t}}function Qr(o){return o.map(e=>"memcmp"in e?{...e,memcmp:{...e.memcmp,encoding:e.memcmp.encoding??"base58"}}:e)}function bo(o){return Ie([g({jsonrpc:re("2.0"),id:k(),result:o}),g({jsonrpc:re("2.0"),id:k(),error:g({code:Ot(),message:k(),data:L(ma())})})])}const Bc=bo(Ot());function N(o){return Yt(bo(o),Bc,e=>"error"in e?e:{...e,result:S(e.result,o)})}function ae(o){return N(g({context:g({slot:d()}),value:o}))}function In(o){return g({context:g({slot:d()}),value:o})}function Dn(o,e){return o===0?new Bt({header:e.header,staticAccountKeys:e.accountKeys.map(t=>new I(t)),recentBlockhash:e.recentBlockhash,compiledInstructions:e.instructions.map(t=>({programIdIndex:t.programIdIndex,accountKeyIndexes:t.accounts,data:pe.decode(t.data)})),addressTableLookups:e.addressTableLookups}):new Ge(e)}const vc=g({foundation:d(),foundationTerm:d(),initial:d(),taper:d(),terminal:d()}),Pc=N(_(E(g({epoch:d(),effectiveSlot:d(),amount:d(),postBalance:d(),commission:L(E(d()))})))),Tc=_(g({slot:d(),prioritizationFee:d()})),Lc=g({total:d(),validator:d(),foundation:d(),epoch:d()}),Cc=g({epoch:d(),slotIndex:d(),slotsInEpoch:d(),absoluteSlot:d(),blockHeight:L(d()),transactionCount:L(d())}),Oc=g({slotsPerEpoch:d(),leaderScheduleSlotOffset:d(),warmup:je(),firstNormalEpoch:d(),firstNormalSlot:d()}),zc=Zs(k(),_(d())),St=E(Ie([g({}),k()])),Uc=g({err:St}),Nc=re("receivedSignature"),Kc=g({"solana-core":k(),"feature-set":L(d())}),Wc=g({program:k(),programId:se,parsed:Ot()}),Fc=g({programId:se,accounts:_(se),data:k()}),es=ae(g({err:E(Ie([g({}),k()])),logs:E(_(k())),accounts:L(E(_(E(g({executable:je(),owner:k(),lamports:d(),data:_(k()),rentEpoch:L(d())}))))),unitsConsumed:L(d()),returnData:L(E(g({programId:k(),data:lr([k(),re("base64")])}))),innerInstructions:L(E(_(g({index:d(),instructions:_(Ie([Wc,Fc]))}))))})),Dc=ae(g({byIdentity:Zs(k(),_(d())),range:g({firstSlot:d(),lastSlot:d()})}));function Mc(o,e,t,n,r,s){const i=t||wc;let a;s!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let c;return n&&(c=async(u,p)=>{const b=await new Promise((f,m)=>{try{n(u,p,(y,w)=>f([y,w]))}catch(y){m(y)}});return await i(...b)}),new ja(async(u,p)=>{const b={method:"POST",body:u,agent:a,headers:Object.assign({"Content-Type":"application/json"},e||{},qu)};try{let f=5,m,y=500;for(;c?m=await c(o,b):m=await i(o,b),!(m.status!==429||r===!0||(f-=1,f===0));)console.error(`Server responded with ${m.status} ${m.statusText}.  Retrying after ${y}ms delay...`),await gt(y),y*=2;const w=await m.text();m.ok?p(null,w):p(new Error(`${m.status} ${m.statusText}: ${w}`))}catch(f){f instanceof Error&&p(f)}},{})}function qc(o){return(e,t)=>new Promise((n,r)=>{o.request(e,t,(s,i)=>{if(s){r(s);return}n(i)})})}function Hc(o){return e=>new Promise((t,n)=>{e.length===0&&t([]);const r=e.map(s=>o.request(s.methodName,s.args));o.request(r,(s,i)=>{if(s){n(s);return}t(i)})})}const $c=N(vc),Vc=N(Lc),jc=N(Tc),Gc=N(Cc),Yc=N(Oc),Jc=N(zc),Xc=N(d()),Zc=ae(g({total:d(),circulating:d(),nonCirculating:d(),nonCirculatingAccounts:_(se)})),jn=g({amount:k(),uiAmount:E(d()),decimals:d(),uiAmountString:L(k())}),Qc=ae(_(g({address:se,amount:k(),uiAmount:E(d()),decimals:d(),uiAmountString:L(k())}))),eu=ae(_(g({pubkey:se,account:g({executable:je(),owner:se,lamports:d(),data:pr,rentEpoch:d()})}))),Gn=g({program:k(),parsed:Ot(),space:d()}),tu=ae(_(g({pubkey:se,account:g({executable:je(),owner:se,lamports:d(),data:Gn,rentEpoch:d()})}))),nu=ae(_(g({lamports:d(),address:se}))),$t=g({executable:je(),owner:se,lamports:d(),data:pr,rentEpoch:d()}),ru=g({pubkey:se,account:$t}),su=Yt(Ie([ur(T.Buffer),Gn]),Ie([go,Gn]),o=>Array.isArray(o)?S(o,pr):o),Yn=g({executable:je(),owner:se,lamports:d(),data:su,rentEpoch:d()}),ou=g({pubkey:se,account:Yn}),iu=g({state:Ie([re("active"),re("inactive"),re("activating"),re("deactivating")]),active:d(),inactive:d()}),au=N(_(g({signature:k(),slot:d(),err:St,memo:E(k()),blockTime:L(E(d()))}))),cu=N(_(g({signature:k(),slot:d(),err:St,memo:E(k()),blockTime:L(E(d()))}))),uu=g({subscription:d(),result:In($t)}),lu=g({pubkey:se,account:$t}),du=g({subscription:d(),result:In(lu)}),hu=g({parent:d(),slot:d(),root:d()}),fu=g({subscription:d(),result:hu}),pu=Ie([g({type:Ie([re("firstShredReceived"),re("completed"),re("optimisticConfirmation"),re("root")]),slot:d(),timestamp:d()}),g({type:re("createdBank"),parent:d(),slot:d(),timestamp:d()}),g({type:re("frozen"),slot:d(),timestamp:d(),stats:g({numTransactionEntries:d(),numSuccessfulTransactions:d(),numFailedTransactions:d(),maxTransactionsPerEntry:d()})}),g({type:re("dead"),slot:d(),timestamp:d(),err:k()})]),yu=g({subscription:d(),result:pu}),gu=g({subscription:d(),result:In(Ie([Uc,Nc]))}),bu=g({subscription:d(),result:d()}),mu=g({pubkey:k(),gossip:E(k()),tpu:E(k()),rpc:E(k()),version:E(k())}),ts=g({votePubkey:k(),nodePubkey:k(),activatedStake:d(),epochVoteAccount:je(),epochCredits:_(lr([d(),d(),d()])),commission:d(),lastVote:d(),rootSlot:E(d())}),ku=N(g({current:_(ts),delinquent:_(ts)})),wu=Ie([re("processed"),re("confirmed"),re("finalized")]),Su=g({slot:d(),confirmations:E(d()),err:St,confirmationStatus:L(wu)}),Iu=ae(_(E(Su))),Au=N(d()),mo=g({accountKey:se,writableIndexes:_(d()),readonlyIndexes:_(d())}),yr=g({signatures:_(k()),message:g({accountKeys:_(k()),header:g({numRequiredSignatures:d(),numReadonlySignedAccounts:d(),numReadonlyUnsignedAccounts:d()}),instructions:_(g({accounts:_(d()),data:k(),programIdIndex:d()})),recentBlockhash:k(),addressTableLookups:L(_(mo))})}),ko=g({pubkey:se,signer:je(),writable:je(),source:L(Ie([re("transaction"),re("lookupTable")]))}),wo=g({accountKeys:_(ko),signatures:_(k())}),So=g({parsed:Ot(),program:k(),programId:se}),Io=g({accounts:_(se),data:k(),programId:se}),_u=Ie([Io,So]),Eu=Ie([g({parsed:Ot(),program:k(),programId:k()}),g({accounts:_(k()),data:k(),programId:k()})]),Ao=Yt(_u,Eu,o=>"accounts"in o?S(o,Io):S(o,So)),_o=g({signatures:_(k()),message:g({accountKeys:_(ko),instructions:_(Ao),recentBlockhash:k(),addressTableLookups:L(E(_(mo)))})}),pn=g({accountIndex:d(),mint:k(),owner:L(k()),programId:L(k()),uiTokenAmount:jn}),Eo=g({writable:_(se),readonly:_(se)}),An=g({err:St,fee:d(),innerInstructions:L(E(_(g({index:d(),instructions:_(g({accounts:_(d()),data:k(),programIdIndex:d()}))})))),preBalances:_(d()),postBalances:_(d()),logMessages:L(E(_(k()))),preTokenBalances:L(E(_(pn))),postTokenBalances:L(E(_(pn))),loadedAddresses:L(Eo),computeUnitsConsumed:L(d())}),gr=g({err:St,fee:d(),innerInstructions:L(E(_(g({index:d(),instructions:_(Ao)})))),preBalances:_(d()),postBalances:_(d()),logMessages:L(E(_(k()))),preTokenBalances:L(E(_(pn))),postTokenBalances:L(E(_(pn))),loadedAddresses:L(Eo),computeUnitsConsumed:L(d())}),zt=Ie([re(0),re("legacy")]),It=g({pubkey:k(),lamports:d(),postBalance:E(d()),rewardType:E(k()),commission:L(E(d()))}),xu=N(E(g({blockhash:k(),previousBlockhash:k(),parentSlot:d(),transactions:_(g({transaction:yr,meta:E(An),version:L(zt)})),rewards:L(_(It)),blockTime:E(d()),blockHeight:E(d())}))),Ru=N(E(g({blockhash:k(),previousBlockhash:k(),parentSlot:d(),rewards:L(_(It)),blockTime:E(d()),blockHeight:E(d())}))),Bu=N(E(g({blockhash:k(),previousBlockhash:k(),parentSlot:d(),transactions:_(g({transaction:wo,meta:E(An),version:L(zt)})),rewards:L(_(It)),blockTime:E(d()),blockHeight:E(d())}))),vu=N(E(g({blockhash:k(),previousBlockhash:k(),parentSlot:d(),transactions:_(g({transaction:_o,meta:E(gr),version:L(zt)})),rewards:L(_(It)),blockTime:E(d()),blockHeight:E(d())}))),Pu=N(E(g({blockhash:k(),previousBlockhash:k(),parentSlot:d(),transactions:_(g({transaction:wo,meta:E(gr),version:L(zt)})),rewards:L(_(It)),blockTime:E(d()),blockHeight:E(d())}))),Tu=N(E(g({blockhash:k(),previousBlockhash:k(),parentSlot:d(),rewards:L(_(It)),blockTime:E(d()),blockHeight:E(d())}))),Lu=N(E(g({blockhash:k(),previousBlockhash:k(),parentSlot:d(),transactions:_(g({transaction:yr,meta:E(An)})),rewards:L(_(It)),blockTime:E(d())}))),ns=N(E(g({blockhash:k(),previousBlockhash:k(),parentSlot:d(),signatures:_(k()),blockTime:E(d())}))),Mn=N(E(g({slot:d(),meta:E(An),blockTime:L(E(d())),transaction:yr,version:L(zt)}))),tn=N(E(g({slot:d(),transaction:_o,meta:E(gr),blockTime:L(E(d())),version:L(zt)}))),Cu=ae(g({blockhash:k(),feeCalculator:g({lamportsPerSignature:d()})})),Ou=ae(g({blockhash:k(),lastValidBlockHeight:d()})),zu=ae(je()),Uu=g({slot:d(),numTransactions:d(),numSlots:d(),samplePeriodSecs:d()}),Nu=N(_(Uu)),Ku=ae(E(g({feeCalculator:g({lamportsPerSignature:d()})}))),Wu=N(k()),Fu=N(k()),Du=g({err:St,logs:_(k()),signature:k()}),Mu=g({result:In(Du),subscription:d()}),qu={"solana-client":"js/1.95.8"};class bl{constructor(e,t){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const l={};return async u=>{const{commitment:p,config:b}=Q(u),f=this._buildArgs([],p,void 0,b),m=Jr(f);return l[m]=l[m]??(async()=>{try{const y=await this._rpcRequest("getBlockHeight",f),w=S(y,N(d()));if("error"in w)throw new v(w.error,"failed to get block height information");return w.result}finally{delete l[m]}})(),await l[m]}})();let n,r,s,i,a,c;t&&typeof t=="string"?this._commitment=t:t&&(this._commitment=t.commitment,this._confirmTransactionInitialTimeout=t.confirmTransactionInitialTimeout,n=t.wsEndpoint,r=t.httpHeaders,s=t.fetch,i=t.fetchMiddleware,a=t.disableRetryOnRateLimit,c=t.httpAgent),this._rpcEndpoint=Rc(e),this._rpcWsEndpoint=n||Ec(e),this._rpcClient=Mc(e,r,s,i,a,c),this._rpcRequest=qc(this._rpcClient),this._rpcBatchRequest=Hc(this._rpcClient),this._rpcWebSocket=new Sc(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(e,t){const{commitment:n,config:r}=Q(t),s=this._buildArgs([e.toBase58()],n,void 0,r),i=await this._rpcRequest("getBalance",s),a=S(i,ae(d()));if("error"in a)throw new v(a.error,`failed to get balance for ${e.toBase58()}`);return a.result}async getBalance(e,t){return await this.getBalanceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get balance of account "+e.toBase58()+": "+n)})}async getBlockTime(e){const t=await this._rpcRequest("getBlockTime",[e]),n=S(t,N(E(d())));if("error"in n)throw new v(n.error,`failed to get block time for slot ${e}`);return n.result}async getMinimumLedgerSlot(){const e=await this._rpcRequest("minimumLedgerSlot",[]),t=S(e,N(d()));if("error"in t)throw new v(t.error,"failed to get minimum ledger slot");return t.result}async getFirstAvailableBlock(){const e=await this._rpcRequest("getFirstAvailableBlock",[]),t=S(e,Xc);if("error"in t)throw new v(t.error,"failed to get first available block");return t.result}async getSupply(e){let t={};typeof e=="string"?t={commitment:e}:e?t={...e,commitment:e&&e.commitment||this.commitment}:t={commitment:this.commitment};const n=await this._rpcRequest("getSupply",[t]),r=S(n,Zc);if("error"in r)throw new v(r.error,"failed to get supply");return r.result}async getTokenSupply(e,t){const n=this._buildArgs([e.toBase58()],t),r=await this._rpcRequest("getTokenSupply",n),s=S(r,ae(jn));if("error"in s)throw new v(s.error,"failed to get token supply");return s.result}async getTokenAccountBalance(e,t){const n=this._buildArgs([e.toBase58()],t),r=await this._rpcRequest("getTokenAccountBalance",n),s=S(r,ae(jn));if("error"in s)throw new v(s.error,"failed to get token account balance");return s.result}async getTokenAccountsByOwner(e,t,n){const{commitment:r,config:s}=Q(n);let i=[e.toBase58()];"mint"in t?i.push({mint:t.mint.toBase58()}):i.push({programId:t.programId.toBase58()});const a=this._buildArgs(i,r,"base64",s),c=await this._rpcRequest("getTokenAccountsByOwner",a),l=S(c,eu);if("error"in l)throw new v(l.error,`failed to get token accounts owned by account ${e.toBase58()}`);return l.result}async getParsedTokenAccountsByOwner(e,t,n){let r=[e.toBase58()];"mint"in t?r.push({mint:t.mint.toBase58()}):r.push({programId:t.programId.toBase58()});const s=this._buildArgs(r,n,"jsonParsed"),i=await this._rpcRequest("getTokenAccountsByOwner",s),a=S(i,tu);if("error"in a)throw new v(a.error,`failed to get token accounts owned by account ${e.toBase58()}`);return a.result}async getLargestAccounts(e){const t={...e,commitment:e&&e.commitment||this.commitment},n=t.filter||t.commitment?[t]:[],r=await this._rpcRequest("getLargestAccounts",n),s=S(r,nu);if("error"in s)throw new v(s.error,"failed to get largest accounts");return s.result}async getTokenLargestAccounts(e,t){const n=this._buildArgs([e.toBase58()],t),r=await this._rpcRequest("getTokenLargestAccounts",n),s=S(r,Qc);if("error"in s)throw new v(s.error,"failed to get token largest accounts");return s.result}async getAccountInfoAndContext(e,t){const{commitment:n,config:r}=Q(t),s=this._buildArgs([e.toBase58()],n,"base64",r),i=await this._rpcRequest("getAccountInfo",s),a=S(i,ae(E($t)));if("error"in a)throw new v(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getParsedAccountInfo(e,t){const{commitment:n,config:r}=Q(t),s=this._buildArgs([e.toBase58()],n,"jsonParsed",r),i=await this._rpcRequest("getAccountInfo",s),a=S(i,ae(E(Yn)));if("error"in a)throw new v(a.error,`failed to get info about account ${e.toBase58()}`);return a.result}async getAccountInfo(e,t){try{return(await this.getAccountInfoAndContext(e,t)).value}catch(n){throw new Error("failed to get info about account "+e.toBase58()+": "+n)}}async getMultipleParsedAccounts(e,t){const{commitment:n,config:r}=Q(t),s=e.map(l=>l.toBase58()),i=this._buildArgs([s],n,"jsonParsed",r),a=await this._rpcRequest("getMultipleAccounts",i),c=S(a,ae(_(E(Yn))));if("error"in c)throw new v(c.error,`failed to get info for accounts ${s}`);return c.result}async getMultipleAccountsInfoAndContext(e,t){const{commitment:n,config:r}=Q(t),s=e.map(l=>l.toBase58()),i=this._buildArgs([s],n,"base64",r),a=await this._rpcRequest("getMultipleAccounts",i),c=S(a,ae(_(E($t))));if("error"in c)throw new v(c.error,`failed to get info for accounts ${s}`);return c.result}async getMultipleAccountsInfo(e,t){return(await this.getMultipleAccountsInfoAndContext(e,t)).value}async getStakeActivation(e,t,n){const{commitment:r,config:s}=Q(t),i=this._buildArgs([e.toBase58()],r,void 0,{...s,epoch:n??(s==null?void 0:s.epoch)}),a=await this._rpcRequest("getStakeActivation",i),c=S(a,N(iu));if("error"in c)throw new v(c.error,`failed to get Stake Activation ${e.toBase58()}`);return c.result}async getProgramAccounts(e,t){const{commitment:n,config:r}=Q(t),{encoding:s,...i}=r||{},a=this._buildArgs([e.toBase58()],n,s||"base64",{...i,...i.filters?{filters:Qr(i.filters)}:null}),c=await this._rpcRequest("getProgramAccounts",a),l=_(ru),u=i.withContext===!0?S(c,ae(l)):S(c,N(l));if("error"in u)throw new v(u.error,`failed to get accounts owned by program ${e.toBase58()}`);return u.result}async getParsedProgramAccounts(e,t){const{commitment:n,config:r}=Q(t),s=this._buildArgs([e.toBase58()],n,"jsonParsed",r),i=await this._rpcRequest("getProgramAccounts",s),a=S(i,N(_(ou)));if("error"in a)throw new v(a.error,`failed to get accounts owned by program ${e.toBase58()}`);return a.result}async confirmTransaction(e,t){var s;let n;if(typeof e=="string")n=e;else{const i=e;if((s=i.abortSignal)!=null&&s.aborted)return Promise.reject(i.abortSignal.reason);n=i.signature}let r;try{r=pe.decode(n)}catch{throw new Error("signature must be base58 encoded: "+n)}return H(r.length===64,"signature has invalid length"),typeof e=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:t||this.commitment,signature:n}):"lastValidBlockHeight"in e?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:t||this.commitment,strategy:e}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:t||this.commitment,strategy:e})}getCancellationPromise(e){return new Promise((t,n)=>{e!=null&&(e.aborted?n(e.reason):e.addEventListener("abort",()=>{n(e.reason)}))})}getTransactionConfirmationPromise({commitment:e,signature:t}){let n,r,s=!1;const i=new Promise((c,l)=>{try{n=this.onSignature(t,(p,b)=>{n=void 0;const f={context:b,value:p};c({__type:at.PROCESSED,response:f})},e);const u=new Promise(p=>{n==null?p():r=this._onSubscriptionStateChange(n,b=>{b==="subscribed"&&p()})});(async()=>{if(await u,s)return;const p=await this.getSignatureStatus(t);if(s||p==null)return;const{context:b,value:f}=p;if(f!=null)if(f!=null&&f.err)l(f.err);else{switch(e){case"confirmed":case"single":case"singleGossip":{if(f.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(f.confirmationStatus==="processed"||f.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}s=!0,c({__type:at.PROCESSED,response:{context:b,value:f}})}})()}catch(u){l(u)}});return{abortConfirmation:()=>{r&&(r(),r=void 0),n!=null&&(this.removeSignatureListener(n),n=void 0)},confirmationPromise:i}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:e,strategy:{abortSignal:t,lastValidBlockHeight:n,signature:r}}){let s=!1;const i=new Promise(p=>{const b=async()=>{try{return await this.getBlockHeight(e)}catch{return-1}};(async()=>{let f=await b();if(!s){for(;f<=n;)if(await gt(1e3),s||(f=await b(),s))return;p({__type:at.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:c}=this.getTransactionConfirmationPromise({commitment:e,signature:r}),l=this.getCancellationPromise(t);let u;try{const p=await Promise.race([l,c,i]);if(p.__type===at.PROCESSED)u=p.response;else throw new io(r)}finally{s=!0,a()}return u}async confirmTransactionUsingDurableNonceStrategy({commitment:e,strategy:{abortSignal:t,minContextSlot:n,nonceAccountPubkey:r,nonceValue:s,signature:i}}){let a=!1;const c=new Promise(f=>{let m=s,y=null;const w=async()=>{try{const{context:P,value:F}=await this.getNonceAndContext(r,{commitment:e,minContextSlot:n});return y=P.slot,F==null?void 0:F.nonce}catch{return m}};(async()=>{if(m=await w(),!a)for(;;){if(s!==m){f({__type:at.NONCE_INVALID,slotInWhichNonceDidAdvance:y});return}if(await gt(2e3),a||(m=await w(),a))return}})()}),{abortConfirmation:l,confirmationPromise:u}=this.getTransactionConfirmationPromise({commitment:e,signature:i}),p=this.getCancellationPromise(t);let b;try{const f=await Promise.race([p,u,c]);if(f.__type===at.PROCESSED)b=f.response;else{let m;for(;;){const y=await this.getSignatureStatus(i);if(y==null)break;if(y.context.slot<(f.slotInWhichNonceDidAdvance??n)){await gt(400);continue}m=y;break}if(m!=null&&m.value){const y=e||"finalized",{confirmationStatus:w}=m.value;switch(y){case"processed":case"recent":if(w!=="processed"&&w!=="confirmed"&&w!=="finalized")throw new Ft(i);break;case"confirmed":case"single":case"singleGossip":if(w!=="confirmed"&&w!=="finalized")throw new Ft(i);break;case"finalized":case"max":case"root":if(w!=="finalized")throw new Ft(i);break;default:}b={context:m.context,value:{err:m.value.err}}}else throw new Ft(i)}}finally{a=!0,l()}return b}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:e,signature:t}){let n;const r=new Promise(c=>{let l=this._confirmTransactionInitialTimeout||6e4;switch(e){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{l=this._confirmTransactionInitialTimeout||3e4;break}}n=setTimeout(()=>c({__type:at.TIMED_OUT,timeoutMs:l}),l)}),{abortConfirmation:s,confirmationPromise:i}=this.getTransactionConfirmationPromise({commitment:e,signature:t});let a;try{const c=await Promise.race([i,r]);if(c.__type===at.PROCESSED)a=c.response;else throw new ao(t,c.timeoutMs/1e3)}finally{clearTimeout(n),s()}return a}async getClusterNodes(){const e=await this._rpcRequest("getClusterNodes",[]),t=S(e,N(_(mu)));if("error"in t)throw new v(t.error,"failed to get cluster nodes");return t.result}async getVoteAccounts(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getVoteAccounts",t),r=S(n,ku);if("error"in r)throw new v(r.error,"failed to get vote accounts");return r.result}async getSlot(e){const{commitment:t,config:n}=Q(e),r=this._buildArgs([],t,void 0,n),s=await this._rpcRequest("getSlot",r),i=S(s,N(d()));if("error"in i)throw new v(i.error,"failed to get slot");return i.result}async getSlotLeader(e){const{commitment:t,config:n}=Q(e),r=this._buildArgs([],t,void 0,n),s=await this._rpcRequest("getSlotLeader",r),i=S(s,N(k()));if("error"in i)throw new v(i.error,"failed to get slot leader");return i.result}async getSlotLeaders(e,t){const n=[e,t],r=await this._rpcRequest("getSlotLeaders",n),s=S(r,N(_(se)));if("error"in s)throw new v(s.error,"failed to get slot leaders");return s.result}async getSignatureStatus(e,t){const{context:n,value:r}=await this.getSignatureStatuses([e],t);H(r.length===1);const s=r[0];return{context:n,value:s}}async getSignatureStatuses(e,t){const n=[e];t&&n.push(t);const r=await this._rpcRequest("getSignatureStatuses",n),s=S(r,Iu);if("error"in s)throw new v(s.error,"failed to get signature status");return s.result}async getTransactionCount(e){const{commitment:t,config:n}=Q(e),r=this._buildArgs([],t,void 0,n),s=await this._rpcRequest("getTransactionCount",r),i=S(s,N(d()));if("error"in i)throw new v(i.error,"failed to get transaction count");return i.result}async getTotalSupply(e){return(await this.getSupply({commitment:e,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getInflationGovernor",t),r=S(n,$c);if("error"in r)throw new v(r.error,"failed to get inflation");return r.result}async getInflationReward(e,t,n){const{commitment:r,config:s}=Q(n),i=this._buildArgs([e.map(l=>l.toBase58())],r,void 0,{...s,epoch:t??(s==null?void 0:s.epoch)}),a=await this._rpcRequest("getInflationReward",i),c=S(a,Pc);if("error"in c)throw new v(c.error,"failed to get inflation reward");return c.result}async getInflationRate(){const e=await this._rpcRequest("getInflationRate",[]),t=S(e,Vc);if("error"in t)throw new v(t.error,"failed to get inflation rate");return t.result}async getEpochInfo(e){const{commitment:t,config:n}=Q(e),r=this._buildArgs([],t,void 0,n),s=await this._rpcRequest("getEpochInfo",r),i=S(s,Gc);if("error"in i)throw new v(i.error,"failed to get epoch info");return i.result}async getEpochSchedule(){const e=await this._rpcRequest("getEpochSchedule",[]),t=S(e,Yc);if("error"in t)throw new v(t.error,"failed to get epoch schedule");const n=t.result;return new kc(n.slotsPerEpoch,n.leaderScheduleSlotOffset,n.warmup,n.firstNormalEpoch,n.firstNormalSlot)}async getLeaderSchedule(){const e=await this._rpcRequest("getLeaderSchedule",[]),t=S(e,Jc);if("error"in t)throw new v(t.error,"failed to get leader schedule");return t.result}async getMinimumBalanceForRentExemption(e,t){const n=this._buildArgs([e],t),r=await this._rpcRequest("getMinimumBalanceForRentExemption",n),s=S(r,Au);return"error"in s?(console.warn("Unable to fetch minimum balance for rent exemption"),0):s.result}async getRecentBlockhashAndContext(e){const t=this._buildArgs([],e),n=await this._rpcRequest("getRecentBlockhash",t),r=S(n,Cu);if("error"in r)throw new v(r.error,"failed to get recent blockhash");return r.result}async getRecentPerformanceSamples(e){const t=await this._rpcRequest("getRecentPerformanceSamples",e?[e]:[]),n=S(t,Nu);if("error"in n)throw new v(n.error,"failed to get recent performance samples");return n.result}async getFeeCalculatorForBlockhash(e,t){const n=this._buildArgs([e],t),r=await this._rpcRequest("getFeeCalculatorForBlockhash",n),s=S(r,Ku);if("error"in s)throw new v(s.error,"failed to get fee calculator");const{context:i,value:a}=s.result;return{context:i,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(e,t){const n=K(e.serialize()).toString("base64"),r=this._buildArgs([n],t),s=await this._rpcRequest("getFeeForMessage",r),i=S(s,ae(E(d())));if("error"in i)throw new v(i.error,"failed to get fee for message");if(i.result===null)throw new Error("invalid blockhash");return i.result}async getRecentPrioritizationFees(e){var i;const t=(i=e==null?void 0:e.lockedWritableAccounts)==null?void 0:i.map(a=>a.toBase58()),n=t!=null&&t.length?[t]:[],r=await this._rpcRequest("getRecentPrioritizationFees",n),s=S(r,jc);if("error"in s)throw new v(s.error,"failed to get recent prioritization fees");return s.result}async getRecentBlockhash(e){try{return(await this.getRecentBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhash(e){try{return(await this.getLatestBlockhashAndContext(e)).value}catch(t){throw new Error("failed to get recent blockhash: "+t)}}async getLatestBlockhashAndContext(e){const{commitment:t,config:n}=Q(e),r=this._buildArgs([],t,void 0,n),s=await this._rpcRequest("getLatestBlockhash",r),i=S(s,Ou);if("error"in i)throw new v(i.error,"failed to get latest blockhash");return i.result}async isBlockhashValid(e,t){const{commitment:n,config:r}=Q(t),s=this._buildArgs([e],n,void 0,r),i=await this._rpcRequest("isBlockhashValid",s),a=S(i,zu);if("error"in a)throw new v(a.error,"failed to determine if the blockhash `"+e+"`is valid");return a.result}async getVersion(){const e=await this._rpcRequest("getVersion",[]),t=S(e,N(Kc));if("error"in t)throw new v(t.error,"failed to get version");return t.result}async getGenesisHash(){const e=await this._rpcRequest("getGenesisHash",[]),t=S(e,N(k()));if("error"in t)throw new v(t.error,"failed to get genesis hash");return t.result}async getBlock(e,t){const{commitment:n,config:r}=Q(t),s=this._buildArgsAtLeastConfirmed([e],n,void 0,r),i=await this._rpcRequest("getBlock",s);try{switch(r==null?void 0:r.transactionDetails){case"accounts":{const a=S(i,Bu);if("error"in a)throw a.error;return a.result}case"none":{const a=S(i,Ru);if("error"in a)throw a.error;return a.result}default:{const a=S(i,xu);if("error"in a)throw a.error;const{result:c}=a;return c?{...c,transactions:c.transactions.map(({transaction:l,meta:u,version:p})=>({meta:u,transaction:{...l,message:Dn(p,l.message)},version:p}))}:null}}}catch(a){throw new v(a,"failed to get confirmed block")}}async getParsedBlock(e,t){const{commitment:n,config:r}=Q(t),s=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",r),i=await this._rpcRequest("getBlock",s);try{switch(r==null?void 0:r.transactionDetails){case"accounts":{const a=S(i,Pu);if("error"in a)throw a.error;return a.result}case"none":{const a=S(i,Tu);if("error"in a)throw a.error;return a.result}default:{const a=S(i,vu);if("error"in a)throw a.error;return a.result}}}catch(a){throw new v(a,"failed to get block")}}async getBlockProduction(e){let t,n;if(typeof e=="string")n=e;else if(e){const{commitment:a,...c}=e;n=a,t=c}const r=this._buildArgs([],n,"base64",t),s=await this._rpcRequest("getBlockProduction",r),i=S(s,Dc);if("error"in i)throw new v(i.error,"failed to get block production information");return i.result}async getTransaction(e,t){const{commitment:n,config:r}=Q(t),s=this._buildArgsAtLeastConfirmed([e],n,void 0,r),i=await this._rpcRequest("getTransaction",s),a=S(i,Mn);if("error"in a)throw new v(a.error,"failed to get transaction");const c=a.result;return c&&{...c,transaction:{...c.transaction,message:Dn(c.version,c.transaction.message)}}}async getParsedTransaction(e,t){const{commitment:n,config:r}=Q(t),s=this._buildArgsAtLeastConfirmed([e],n,"jsonParsed",r),i=await this._rpcRequest("getTransaction",s),a=S(i,tn);if("error"in a)throw new v(a.error,"failed to get transaction");return a.result}async getParsedTransactions(e,t){const{commitment:n,config:r}=Q(t),s=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,"jsonParsed",r)}));return(await this._rpcBatchRequest(s)).map(c=>{const l=S(c,tn);if("error"in l)throw new v(l.error,"failed to get transactions");return l.result})}async getTransactions(e,t){const{commitment:n,config:r}=Q(t),s=e.map(c=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([c],n,void 0,r)}));return(await this._rpcBatchRequest(s)).map(c=>{const l=S(c,Mn);if("error"in l)throw new v(l.error,"failed to get transactions");const u=l.result;return u&&{...u,transaction:{...u.transaction,message:Dn(u.version,u.transaction.message)}}})}async getConfirmedBlock(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),r=await this._rpcRequest("getConfirmedBlock",n),s=S(r,Lu);if("error"in s)throw new v(s.error,"failed to get confirmed block");const i=s.result;if(!i)throw new Error("Confirmed block "+e+" not found");const a={...i,transactions:i.transactions.map(({transaction:c,meta:l})=>{const u=new Ge(c.message);return{meta:l,transaction:{...c,message:u}}})};return{...a,transactions:a.transactions.map(({transaction:c,meta:l})=>({meta:l,transaction:G.populate(c.message,c.signatures)}))}}async getBlocks(e,t,n){const r=this._buildArgsAtLeastConfirmed(t!==void 0?[e,t]:[e],n),s=await this._rpcRequest("getBlocks",r),i=S(s,N(_(d())));if("error"in i)throw new v(i.error,"failed to get blocks");return i.result}async getBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),r=await this._rpcRequest("getBlock",n),s=S(r,ns);if("error"in s)throw new v(s.error,"failed to get block");const i=s.result;if(!i)throw new Error("Block "+e+" not found");return i}async getConfirmedBlockSignatures(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,void 0,{transactionDetails:"signatures",rewards:!1}),r=await this._rpcRequest("getConfirmedBlock",n),s=S(r,ns);if("error"in s)throw new v(s.error,"failed to get confirmed block");const i=s.result;if(!i)throw new Error("Confirmed block "+e+" not found");return i}async getConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t),r=await this._rpcRequest("getConfirmedTransaction",n),s=S(r,Mn);if("error"in s)throw new v(s.error,"failed to get transaction");const i=s.result;if(!i)return i;const a=new Ge(i.transaction.message),c=i.transaction.signatures;return{...i,transaction:G.populate(a,c)}}async getParsedConfirmedTransaction(e,t){const n=this._buildArgsAtLeastConfirmed([e],t,"jsonParsed"),r=await this._rpcRequest("getConfirmedTransaction",n),s=S(r,tn);if("error"in s)throw new v(s.error,"failed to get confirmed transaction");return s.result}async getParsedConfirmedTransactions(e,t){const n=e.map(i=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([i],t,"jsonParsed")}));return(await this._rpcBatchRequest(n)).map(i=>{const a=S(i,tn);if("error"in a)throw new v(a.error,"failed to get confirmed transactions");return a.result})}async getConfirmedSignaturesForAddress(e,t,n){let r={},s=await this.getFirstAvailableBlock();for(;!("until"in r)&&(t--,!(t<=0||t<s));)try{const c=await this.getConfirmedBlockSignatures(t,"finalized");c.signatures.length>0&&(r.until=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}let i=await this.getSlot("finalized");for(;!("before"in r)&&(n++,!(n>i));)try{const c=await this.getConfirmedBlockSignatures(n);c.signatures.length>0&&(r.before=c.signatures[c.signatures.length-1].toString())}catch(c){if(c instanceof Error&&c.message.includes("skipped"))continue;throw c}return(await this.getConfirmedSignaturesForAddress2(e,r)).map(c=>c.signature)}async getConfirmedSignaturesForAddress2(e,t,n){const r=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),s=await this._rpcRequest("getConfirmedSignaturesForAddress2",r),i=S(s,au);if("error"in i)throw new v(i.error,"failed to get confirmed signatures for address");return i.result}async getSignaturesForAddress(e,t,n){const r=this._buildArgsAtLeastConfirmed([e.toBase58()],n,void 0,t),s=await this._rpcRequest("getSignaturesForAddress",r),i=S(s,cu);if("error"in i)throw new v(i.error,"failed to get signatures for address");return i.result}async getAddressLookupTable(e,t){const{context:n,value:r}=await this.getAccountInfoAndContext(e,t);let s=null;return r!==null&&(s=new Zr({key:e,state:Zr.deserialize(r.data)})),{context:n,value:s}}async getNonceAndContext(e,t){const{context:n,value:r}=await this.getAccountInfoAndContext(e,t);let s=null;return r!==null&&(s=fr.fromAccountData(r.data)),{context:n,value:s}}async getNonce(e,t){return await this.getNonceAndContext(e,t).then(n=>n.value).catch(n=>{throw new Error("failed to get nonce for account "+e.toBase58()+": "+n)})}async requestAirdrop(e,t){const n=await this._rpcRequest("requestAirdrop",[e.toBase58(),t]),r=S(n,Wu);if("error"in r)throw new v(r.error,`airdrop to ${e.toBase58()} failed`);return r.result}async _blockhashWithExpiryBlockHeight(e){if(!e){for(;this._pollingBlockhash;)await gt(100);const n=Date.now()-this._blockhashInfo.lastFetch>=xc;if(this._blockhashInfo.latestBlockhash!==null&&!n)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const e=Date.now(),t=this._blockhashInfo.latestBlockhash,n=t?t.blockhash:null;for(let r=0;r<50;r++){const s=await this.getLatestBlockhash("finalized");if(n!==s.blockhash)return this._blockhashInfo={latestBlockhash:s,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},s;await gt(po/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-e}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(e){const{commitment:t,config:n}=Q(e),r=this._buildArgs([],t,"base64",n),s=await this._rpcRequest("getStakeMinimumDelegation",r),i=S(s,ae(d()));if("error"in i)throw new v(i.error,"failed to get stake minimum delegation");return i.result}async simulateTransaction(e,t,n){if("message"in e){const y=e.serialize(),w=T.Buffer.from(y).toString("base64");if(Array.isArray(t)||n!==void 0)throw new Error("Invalid arguments");const P=t||{};P.encoding="base64","commitment"in P||(P.commitment=this.commitment),t&&typeof t=="object"&&"innerInstructions"in t&&(P.innerInstructions=t.innerInstructions);const F=[w,P],x=await this._rpcRequest("simulateTransaction",F),J=S(x,es);if("error"in J)throw new Error("failed to simulate transaction: "+J.error.message);return J.result}let r;if(e instanceof G){let m=e;r=new G,r.feePayer=m.feePayer,r.instructions=e.instructions,r.nonceInfo=m.nonceInfo,r.signatures=m.signatures}else r=G.populate(e),r._message=r._json=void 0;if(t!==void 0&&!Array.isArray(t))throw new Error("Invalid arguments");const s=t;if(r.nonceInfo&&s)r.sign(...s);else{let m=this._disableBlockhashCaching;for(;;){const y=await this._blockhashWithExpiryBlockHeight(m);if(r.lastValidBlockHeight=y.lastValidBlockHeight,r.recentBlockhash=y.blockhash,!s)break;if(r.sign(...s),!r.signature)throw new Error("!signature");const w=r.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(w)&&!this._blockhashInfo.transactionSignatures.includes(w)){this._blockhashInfo.simulatedSignatures.push(w);break}else m=!0}}const i=r._compile(),a=i.serialize(),l=r._serialize(a).toString("base64"),u={encoding:"base64",commitment:this.commitment};if(n){const m=(Array.isArray(n)?n:i.nonProgramIds()).map(y=>y.toBase58());u.accounts={encoding:"base64",addresses:m}}s&&(u.sigVerify=!0),t&&typeof t=="object"&&"innerInstructions"in t&&(u.innerInstructions=t.innerInstructions);const p=[l,u],b=await this._rpcRequest("simulateTransaction",p),f=S(b,es);if("error"in f){let m;if("data"in f.error&&(m=f.error.data.logs,m&&Array.isArray(m))){const y=`
    `,w=y+m.join(y);console.error(f.error.message,w)}throw new fn({action:"simulate",signature:"",transactionMessage:f.error.message,logs:m})}return f.result}async sendTransaction(e,t,n){if("version"in e){if(t&&Array.isArray(t))throw new Error("Invalid arguments");const i=e.serialize();return await this.sendRawTransaction(i,t)}if(t===void 0||!Array.isArray(t))throw new Error("Invalid arguments");const r=t;if(e.nonceInfo)e.sign(...r);else{let i=this._disableBlockhashCaching;for(;;){const a=await this._blockhashWithExpiryBlockHeight(i);if(e.lastValidBlockHeight=a.lastValidBlockHeight,e.recentBlockhash=a.blockhash,e.sign(...r),!e.signature)throw new Error("!signature");const c=e.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(c))i=!0;else{this._blockhashInfo.transactionSignatures.push(c);break}}}const s=e.serialize();return await this.sendRawTransaction(s,n)}async sendRawTransaction(e,t){const n=K(e).toString("base64");return await this.sendEncodedTransaction(n,t)}async sendEncodedTransaction(e,t){const n={encoding:"base64"},r=t&&t.skipPreflight,s=r===!0?"processed":t&&t.preflightCommitment||this.commitment;t&&t.maxRetries!=null&&(n.maxRetries=t.maxRetries),t&&t.minContextSlot!=null&&(n.minContextSlot=t.minContextSlot),r&&(n.skipPreflight=r),s&&(n.preflightCommitment=s);const i=[e,n],a=await this._rpcRequest("sendTransaction",i),c=S(a,Fu);if("error"in c){let l;throw"data"in c.error&&(l=c.error.data.logs),new fn({action:r?"send":"simulate",signature:"",transactionMessage:c.error.message,logs:l})}return c.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(e){this._rpcWebSocketConnected=!1,console.error("ws error:",e.message)}_wsOnClose(e){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),e===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([t,n])=>{this._setSubscription(t,{...n,state:"pending"})})}_setSubscription(e,t){var r;const n=(r=this._subscriptionsByHash[e])==null?void 0:r.state;if(this._subscriptionsByHash[e]=t,n!==t.state){const s=this._subscriptionStateChangeCallbacksByHash[e];s&&s.forEach(i=>{try{i(t.state)}catch{}})}}_onSubscriptionStateChange(e,t){var s;const n=this._subscriptionHashByClientSubscriptionId[e];if(n==null)return()=>{};const r=(s=this._subscriptionStateChangeCallbacksByHash)[n]||(s[n]=new Set);return r.add(t),()=>{r.delete(t),r.size===0&&delete this._subscriptionStateChangeCallbacksByHash[n]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(n){n instanceof Error&&console.log(`Error when closing socket connection: ${n.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const e=this._rpcWebSocketGeneration,t=()=>e===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async n=>{const r=this._subscriptionsByHash[n];if(r!==void 0)switch(r.state){case"pending":case"unsubscribed":if(r.callbacks.size===0){delete this._subscriptionsByHash[n],r.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[r.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:s,method:i}=r;try{this._setSubscription(n,{...r,state:"subscribing"});const a=await this._rpcWebSocket.call(i,s);this._setSubscription(n,{...r,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=r.callbacks,await this._updateSubscriptions()}catch(a){if(console.error(`Received ${a instanceof Error?"":"JSON-RPC "}error calling \`${i}\``,{args:s,error:a}),!t())return;this._setSubscription(n,{...r,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":r.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:s,unsubscribeMethod:i}=r;if(this._subscriptionsAutoDisposedByRpc.has(s))this._subscriptionsAutoDisposedByRpc.delete(s);else{this._setSubscription(n,{...r,state:"unsubscribing"}),this._setSubscription(n,{...r,state:"unsubscribing"});try{await this._rpcWebSocket.call(i,[s])}catch(a){if(a instanceof Error&&console.error(`${i} error:`,a.message),!t())return;this._setSubscription(n,{...r,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(n,{...r,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(e,t){const n=this._subscriptionCallbacksByServerSubscriptionId[e];n!==void 0&&n.forEach(r=>{try{r(...t)}catch(s){console.error(s)}})}_wsOnAccountNotification(e){const{result:t,subscription:n}=S(e,uu);this._handleServerNotification(n,[t.value,t.context])}_makeSubscription(e,t){const n=this._nextClientSubscriptionId++,r=Jr([e.method,t]),s=this._subscriptionsByHash[r];return s===void 0?this._subscriptionsByHash[r]={...e,args:t,callbacks:new Set([e.callback]),state:"pending"}:s.callbacks.add(e.callback),this._subscriptionHashByClientSubscriptionId[n]=r,this._subscriptionDisposeFunctionsByClientSubscriptionId[n]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[n],delete this._subscriptionHashByClientSubscriptionId[n];const i=this._subscriptionsByHash[r];H(i!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${n}`),i.callbacks.delete(e.callback),await this._updateSubscriptions()},this._updateSubscriptions(),n}onAccountChange(e,t,n){const{commitment:r,config:s}=Q(n),i=this._buildArgs([e.toBase58()],r||this._commitment||"finalized","base64",s);return this._makeSubscription({callback:t,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},i)}async removeAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"account change")}_wsOnProgramAccountNotification(e){const{result:t,subscription:n}=S(e,du);this._handleServerNotification(n,[{accountId:t.value.pubkey,accountInfo:t.value.account},t.context])}onProgramAccountChange(e,t,n,r){const{commitment:s,config:i}=Q(n),a=this._buildArgs([e.toBase58()],s||this._commitment||"finalized","base64",i||(r?{filters:Qr(r)}:void 0));return this._makeSubscription({callback:t,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},a)}async removeProgramAccountChangeListener(e){await this._unsubscribeClientSubscription(e,"program account change")}onLogs(e,t,n){const r=this._buildArgs([typeof e=="object"?{mentions:[e.toString()]}:e],n||this._commitment||"finalized");return this._makeSubscription({callback:t,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},r)}async removeOnLogsListener(e){await this._unsubscribeClientSubscription(e,"logs")}_wsOnLogsNotification(e){const{result:t,subscription:n}=S(e,Mu);this._handleServerNotification(n,[t.value,t.context])}_wsOnSlotNotification(e){const{result:t,subscription:n}=S(e,fu);this._handleServerNotification(n,[t])}onSlotChange(e){return this._makeSubscription({callback:e,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(e){await this._unsubscribeClientSubscription(e,"slot change")}_wsOnSlotUpdatesNotification(e){const{result:t,subscription:n}=S(e,yu);this._handleServerNotification(n,[t])}onSlotUpdate(e){return this._makeSubscription({callback:e,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(e){await this._unsubscribeClientSubscription(e,"slot update")}async _unsubscribeClientSubscription(e,t){const n=this._subscriptionDisposeFunctionsByClientSubscriptionId[e];n?await n():console.warn(`Ignored unsubscribe request because an active subscription with id \`${e}\` for '${t}' events could not be found.`)}_buildArgs(e,t,n,r){const s=t||this._commitment;if(s||n||r){let i={};n&&(i.encoding=n),s&&(i.commitment=s),r&&(i=Object.assign(i,r)),e.push(i)}return e}_buildArgsAtLeastConfirmed(e,t,n,r){const s=t||this._commitment;if(s&&!["confirmed","finalized"].includes(s))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(e,t,n,r)}_wsOnSignatureNotification(e){const{result:t,subscription:n}=S(e,gu);t.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(n),this._handleServerNotification(n,t.value==="receivedSignature"?[{type:"received"},t.context]:[{type:"status",result:t.value},t.context])}onSignature(e,t,n){const r=this._buildArgs([e],n||this._commitment||"finalized"),s=this._makeSubscription({callback:(i,a)=>{if(i.type==="status"){t(i.result,a);try{this.removeSignatureListener(s)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},r);return s}onSignatureWithOptions(e,t,n){const{commitment:r,...s}={...n,commitment:n&&n.commitment||this._commitment||"finalized"},i=this._buildArgs([e],r,void 0,s),a=this._makeSubscription({callback:(c,l)=>{t(c,l);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},i);return a}async removeSignatureListener(e){await this._unsubscribeClientSubscription(e,"signature result")}_wsOnRootNotification(e){const{result:t,subscription:n}=S(e,bu);this._handleServerNotification(n,[t])}onRootChange(e){return this._makeSubscription({callback:e,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(e){await this._unsubscribeClientSubscription(e,"root change")}}class Dt{constructor(e){this._keypair=void 0,this._keypair=e??Hr()}static generate(){return new Dt(Hr())}static fromSecretKey(e,t){if(e.byteLength!==64)throw new Error("bad secret key size");const n=e.slice(32,64);if(!t||!t.skipValidation){const r=e.slice(0,32),s=ln(r);for(let i=0;i<32;i++)if(n[i]!==s[i])throw new Error("provided secretKey is invalid")}return new Dt({publicKey:n,secretKey:e})}static fromSeed(e){const t=ln(e),n=new Uint8Array(64);return n.set(e),n.set(t,32),new Dt({publicKey:t,secretKey:n})}get publicKey(){return new I(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}const ct=Object.freeze({CreateLookupTable:{index:0,layout:B([R("instruction"),vt("recentSlot"),M("bumpSeed")])},FreezeLookupTable:{index:1,layout:B([R("instruction")])},ExtendLookupTable:{index:2,layout:B([R("instruction"),vt(),ge(W(),dt(R(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:B([R("instruction")])},CloseLookupTable:{index:4,layout:B([R("instruction")])}});class ml{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=R("instruction").decode(e.data);let r;for(const[s,i]of Object.entries(ct))if(i.index==n){r=s;break}if(!r)throw new Error("Invalid Instruction. Should be a LookupTable Instruction");return r}static decodeCreateLookupTable(e){this.checkProgramId(e.programId),this.checkKeysLength(e.keys,4);const{recentSlot:t}=j(ct.CreateLookupTable,e.data);return{authority:e.keys[1].pubkey,payer:e.keys[2].pubkey,recentSlot:Number(t)}}static decodeExtendLookupTable(e){if(this.checkProgramId(e.programId),e.keys.length<2)throw new Error(`invalid instruction; found ${e.keys.length} keys, expected at least 2`);const{addresses:t}=j(ct.ExtendLookupTable,e.data);return{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,payer:e.keys.length>2?e.keys[2].pubkey:void 0,addresses:t.map(n=>new I(n))}}static decodeCloseLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,3),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey,recipient:e.keys[2].pubkey}}static decodeFreezeLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static decodeDeactivateLookupTable(e){return this.checkProgramId(e.programId),this.checkKeysLength(e.keys,2),{lookupTable:e.keys[0].pubkey,authority:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(xo.programId))throw new Error("invalid instruction; programId is not AddressLookupTable Program")}static checkKeysLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}class xo{constructor(){}static createLookupTable(e){const[t,n]=I.findProgramAddressSync([e.authority.toBuffer(),Ys(BigInt(e.recentSlot),8)],this.programId),r=ct.CreateLookupTable,s=D(r,{recentSlot:BigInt(e.recentSlot),bumpSeed:n}),i=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:ye.programId,isSigner:!1,isWritable:!1}];return[new ee({programId:this.programId,keys:i,data:s}),t]}static freezeLookupTable(e){const t=ct.FreezeLookupTable,n=D(t),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new ee({programId:this.programId,keys:r,data:n})}static extendLookupTable(e){const t=ct.ExtendLookupTable,n=D(t,{addresses:e.addresses.map(s=>s.toBytes())}),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return e.payer&&r.push({pubkey:e.payer,isSigner:!0,isWritable:!0},{pubkey:ye.programId,isSigner:!1,isWritable:!1}),new ee({programId:this.programId,keys:r,data:n})}static deactivateLookupTable(e){const t=ct.DeactivateLookupTable,n=D(t),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1}];return new ee({programId:this.programId,keys:r,data:n})}static closeLookupTable(e){const t=ct.CloseLookupTable,n=D(t),r=[{pubkey:e.lookupTable,isSigner:!1,isWritable:!0},{pubkey:e.authority,isSigner:!0,isWritable:!1},{pubkey:e.recipient,isSigner:!1,isWritable:!0}];return new ee({programId:this.programId,keys:r,data:n})}}xo.programId=new I("AddressLookupTab1e1111111111111111111111111");class kl{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=M("instruction").decode(e.data);let r;for(const[s,i]of Object.entries(nt))if(i.index==n){r=s;break}if(!r)throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");return r}static decodeRequestUnits(e){this.checkProgramId(e.programId);const{units:t,additionalFee:n}=j(nt.RequestUnits,e.data);return{units:t,additionalFee:n}}static decodeRequestHeapFrame(e){this.checkProgramId(e.programId);const{bytes:t}=j(nt.RequestHeapFrame,e.data);return{bytes:t}}static decodeSetComputeUnitLimit(e){this.checkProgramId(e.programId);const{units:t}=j(nt.SetComputeUnitLimit,e.data);return{units:t}}static decodeSetComputeUnitPrice(e){this.checkProgramId(e.programId);const{microLamports:t}=j(nt.SetComputeUnitPrice,e.data);return{microLamports:t}}static checkProgramId(e){if(!e.equals(Ro.programId))throw new Error("invalid instruction; programId is not ComputeBudgetProgram")}}const nt=Object.freeze({RequestUnits:{index:0,layout:B([M("instruction"),R("units"),R("additionalFee")])},RequestHeapFrame:{index:1,layout:B([M("instruction"),R("bytes")])},SetComputeUnitLimit:{index:2,layout:B([M("instruction"),R("units")])},SetComputeUnitPrice:{index:3,layout:B([M("instruction"),vt("microLamports")])}});class Ro{constructor(){}static requestUnits(e){const t=nt.RequestUnits,n=D(t,e);return new ee({keys:[],programId:this.programId,data:n})}static requestHeapFrame(e){const t=nt.RequestHeapFrame,n=D(t,e);return new ee({keys:[],programId:this.programId,data:n})}static setComputeUnitLimit(e){const t=nt.SetComputeUnitLimit,n=D(t,e);return new ee({keys:[],programId:this.programId,data:n})}static setComputeUnitPrice(e){const t=nt.SetComputeUnitPrice,n=D(t,{microLamports:BigInt(e.microLamports)});return new ee({keys:[],programId:this.programId,data:n})}}Ro.programId=new I("ComputeBudget111111111111111111111111111111");const rs=64,ss=32,os=64,is=B([M("numSignatures"),M("padding"),ze("signatureOffset"),ze("signatureInstructionIndex"),ze("publicKeyOffset"),ze("publicKeyInstructionIndex"),ze("messageDataOffset"),ze("messageDataSize"),ze("messageInstructionIndex")]);class br{constructor(){}static createInstructionWithPublicKey(e){const{publicKey:t,message:n,signature:r,instructionIndex:s}=e;H(t.length===ss,`Public Key must be ${ss} bytes but received ${t.length} bytes`),H(r.length===os,`Signature must be ${os} bytes but received ${r.length} bytes`);const i=is.span,a=i+t.length,c=a+r.length,l=1,u=T.Buffer.alloc(c+n.length),p=s??65535;return is.encode({numSignatures:l,padding:0,signatureOffset:a,signatureInstructionIndex:p,publicKeyOffset:i,publicKeyInstructionIndex:p,messageDataOffset:c,messageDataSize:n.length,messageInstructionIndex:p},u),u.fill(t,i),u.fill(r,a),u.fill(n,c),new ee({keys:[],programId:br.programId,data:u})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:n,instructionIndex:r}=e;H(t.length===rs,`Private key must be ${rs} bytes but received ${t.length} bytes`);try{const s=Dt.fromSecretKey(t),i=s.publicKey.toBytes(),a=dr(n,s.secretKey);return this.createInstructionWithPublicKey({publicKey:i,message:n,signature:a,instructionIndex:r})}catch(s){throw new Error(`Error creating instruction; ${s}`)}}}br.programId=new I("Ed25519SigVerify111111111111111111111111111");const Hu=(o,e)=>{const t=Jn.sign(o,e);return[t.toCompactRawBytes(),t.recovery]};Jn.utils.isValidPrivateKey;const $u=Jn.getPublicKey,as=32,qn=20,cs=64,Vu=11,Hn=B([M("numSignatures"),ze("signatureOffset"),M("signatureInstructionIndex"),ze("ethAddressOffset"),M("ethAddressInstructionIndex"),ze("messageDataOffset"),ze("messageDataSize"),M("messageInstructionIndex"),ne(20,"ethAddress"),ne(64,"signature"),M("recoveryId")]);class Mt{constructor(){}static publicKeyToEthAddress(e){H(e.length===cs,`Public key must be ${cs} bytes but received ${e.length} bytes`);try{return T.Buffer.from(Wr(K(e))).slice(-qn)}catch(t){throw new Error(`Error constructing Ethereum address: ${t}`)}}static createInstructionWithPublicKey(e){const{publicKey:t,message:n,signature:r,recoveryId:s,instructionIndex:i}=e;return Mt.createInstructionWithEthAddress({ethAddress:Mt.publicKeyToEthAddress(t),message:n,signature:r,recoveryId:s,instructionIndex:i})}static createInstructionWithEthAddress(e){const{ethAddress:t,message:n,signature:r,recoveryId:s,instructionIndex:i=0}=e;let a;typeof t=="string"?t.startsWith("0x")?a=T.Buffer.from(t.substr(2),"hex"):a=T.Buffer.from(t,"hex"):a=t,H(a.length===qn,`Address must be ${qn} bytes but received ${a.length} bytes`);const c=1+Vu,l=c,u=c+a.length,p=u+r.length+1,b=1,f=T.Buffer.alloc(Hn.span+n.length);return Hn.encode({numSignatures:b,signatureOffset:u,signatureInstructionIndex:i,ethAddressOffset:l,ethAddressInstructionIndex:i,messageDataOffset:p,messageDataSize:n.length,messageInstructionIndex:i,signature:K(r),ethAddress:K(a),recoveryId:s},f),f.fill(K(n),Hn.span),new ee({keys:[],programId:Mt.programId,data:f})}static createInstructionWithPrivateKey(e){const{privateKey:t,message:n,instructionIndex:r}=e;H(t.length===as,`Private key must be ${as} bytes but received ${t.length} bytes`);try{const s=K(t),i=$u(s,!1).slice(1),a=T.Buffer.from(Wr(K(n))),[c,l]=Hu(a,s);return this.createInstructionWithPublicKey({publicKey:i,message:n,signature:c,recoveryId:l,instructionIndex:r})}catch(s){throw new Error(`Error creating instruction; ${s}`)}}}Mt.programId=new I("KeccakSecp256k11111111111111111111111111111");var Bo;const ju=new I("StakeConfig11111111111111111111111111111111");class Gu{constructor(e,t){this.staker=void 0,this.withdrawer=void 0,this.staker=e,this.withdrawer=t}}class _n{constructor(e,t,n){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=e,this.epoch=t,this.custodian=n}}Bo=_n;_n.default=new Bo(0,0,I.default);class wl{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=R("instruction").decode(e.data);let r;for(const[s,i]of Object.entries(he))if(i.index==n){r=s;break}if(!r)throw new Error("Instruction type incorrect; not a StakeInstruction");return r}static decodeInitialize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{authorized:t,lockup:n}=j(he.Initialize,e.data);return{stakePubkey:e.keys[0].pubkey,authorized:new Gu(new I(t.staker),new I(t.withdrawer)),lockup:new _n(n.unixTimestamp,n.epoch,new I(n.custodian))}}static decodeDelegate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,6),j(he.Delegate,e.data),{stakePubkey:e.keys[0].pubkey,votePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[5].pubkey}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,stakeAuthorizationType:n}=j(he.Authorize,e.data),r={stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new I(t),stakeAuthorizationType:{index:n}};return e.keys.length>3&&(r.custodianPubkey=e.keys[3].pubkey),r}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,2);const{newAuthorized:t,stakeAuthorizationType:n,authoritySeed:r,authorityOwner:s}=j(he.AuthorizeWithSeed,e.data),i={stakePubkey:e.keys[0].pubkey,authorityBase:e.keys[1].pubkey,authoritySeed:r,authorityOwner:new I(s),newAuthorizedPubkey:new I(t),stakeAuthorizationType:{index:n}};return e.keys.length>3&&(i.custodianPubkey=e.keys[3].pubkey),i}static decodeSplit(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=j(he.Split,e.data);return{stakePubkey:e.keys[0].pubkey,splitStakePubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[2].pubkey,lamports:t}}static decodeMerge(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),j(he.Merge,e.data),{stakePubkey:e.keys[0].pubkey,sourceStakePubKey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,5);const{lamports:t}=j(he.Withdraw,e.data),n={stakePubkey:e.keys[0].pubkey,toPubkey:e.keys[1].pubkey,authorizedPubkey:e.keys[4].pubkey,lamports:t};return e.keys.length>5&&(n.custodianPubkey=e.keys[5].pubkey),n}static decodeDeactivate(e){return this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3),j(he.Deactivate,e.data),{stakePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey}}static checkProgramId(e){if(!e.equals(mr.programId))throw new Error("invalid instruction; programId is not StakeProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const he=Object.freeze({Initialize:{index:0,layout:B([R("instruction"),rc(),sc()])},Authorize:{index:1,layout:B([R("instruction"),W("newAuthorized"),R("stakeAuthorizationType")])},Delegate:{index:2,layout:B([R("instruction")])},Split:{index:3,layout:B([R("instruction"),Pe("lamports")])},Withdraw:{index:4,layout:B([R("instruction"),Pe("lamports")])},Deactivate:{index:5,layout:B([R("instruction")])},Merge:{index:7,layout:B([R("instruction")])},AuthorizeWithSeed:{index:8,layout:B([R("instruction"),W("newAuthorized"),R("stakeAuthorizationType"),bt("authoritySeed"),W("authorityOwner")])}}),Sl=Object.freeze({Staker:{index:0},Withdrawer:{index:1}});class mr{constructor(){}static initialize(e){const{stakePubkey:t,authorized:n,lockup:r}=e,s=r||_n.default,i=he.Initialize,a=D(i,{authorized:{staker:K(n.staker.toBuffer()),withdrawer:K(n.withdrawer.toBuffer())},lockup:{unixTimestamp:s.unixTimestamp,epoch:s.epoch,custodian:K(s.custodian.toBuffer())}}),c={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ht,isSigner:!1,isWritable:!1}],programId:this.programId,data:a};return new ee(c)}static createAccountWithSeed(e){const t=new G;t.add(ye.createAccountWithSeed({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,basePubkey:e.basePubkey,seed:e.seed,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:n,authorized:r,lockup:s}=e;return t.add(this.initialize({stakePubkey:n,authorized:r,lockup:s}))}static createAccount(e){const t=new G;t.add(ye.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.stakePubkey,lamports:e.lamports,space:this.space,programId:this.programId}));const{stakePubkey:n,authorized:r,lockup:s}=e;return t.add(this.initialize({stakePubkey:n,authorized:r,lockup:s}))}static delegate(e){const{stakePubkey:t,authorizedPubkey:n,votePubkey:r}=e,s=he.Delegate,i=D(s);return new G().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!1},{pubkey:et,isSigner:!1,isWritable:!1},{pubkey:Kn,isSigner:!1,isWritable:!1},{pubkey:ju,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static authorize(e){const{stakePubkey:t,authorizedPubkey:n,newAuthorizedPubkey:r,stakeAuthorizationType:s,custodianPubkey:i}=e,a=he.Authorize,c=D(a,{newAuthorized:K(r.toBuffer()),stakeAuthorizationType:s.index}),l=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:et,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return i&&l.push({pubkey:i,isSigner:!0,isWritable:!1}),new G().add({keys:l,programId:this.programId,data:c})}static authorizeWithSeed(e){const{stakePubkey:t,authorityBase:n,authoritySeed:r,authorityOwner:s,newAuthorizedPubkey:i,stakeAuthorizationType:a,custodianPubkey:c}=e,l=he.AuthorizeWithSeed,u=D(l,{newAuthorized:K(i.toBuffer()),stakeAuthorizationType:a.index,authoritySeed:r,authorityOwner:K(s.toBuffer())}),p=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1},{pubkey:et,isSigner:!1,isWritable:!1}];return c&&p.push({pubkey:c,isSigner:!0,isWritable:!1}),new G().add({keys:p,programId:this.programId,data:u})}static splitInstruction(e){const{stakePubkey:t,authorizedPubkey:n,splitStakePubkey:r,lamports:s}=e,i=he.Split,a=D(i,{lamports:s});return new ee({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:a})}static split(e,t){const n=new G;return n.add(ye.createAccount({fromPubkey:e.authorizedPubkey,newAccountPubkey:e.splitStakePubkey,lamports:t,space:this.space,programId:this.programId})),n.add(this.splitInstruction(e))}static splitWithSeed(e,t){const{stakePubkey:n,authorizedPubkey:r,splitStakePubkey:s,basePubkey:i,seed:a,lamports:c}=e,l=new G;return l.add(ye.allocate({accountPubkey:s,basePubkey:i,seed:a,space:this.space,programId:this.programId})),t&&t>0&&l.add(ye.transfer({fromPubkey:e.authorizedPubkey,toPubkey:s,lamports:t})),l.add(this.splitInstruction({stakePubkey:n,authorizedPubkey:r,splitStakePubkey:s,lamports:c}))}static merge(e){const{stakePubkey:t,sourceStakePubKey:n,authorizedPubkey:r}=e,s=he.Merge,i=D(s);return new G().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!1,isWritable:!0},{pubkey:et,isSigner:!1,isWritable:!1},{pubkey:Kn,isSigner:!1,isWritable:!1},{pubkey:r,isSigner:!0,isWritable:!1}],programId:this.programId,data:i})}static withdraw(e){const{stakePubkey:t,authorizedPubkey:n,toPubkey:r,lamports:s,custodianPubkey:i}=e,a=he.Withdraw,c=D(a,{lamports:s}),l=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!1,isWritable:!0},{pubkey:et,isSigner:!1,isWritable:!1},{pubkey:Kn,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return i&&l.push({pubkey:i,isSigner:!0,isWritable:!1}),new G().add({keys:l,programId:this.programId,data:c})}static deactivate(e){const{stakePubkey:t,authorizedPubkey:n}=e,r=he.Deactivate,s=D(r);return new G().add({keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:et,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:s})}}mr.programId=new I("Stake11111111111111111111111111111111111111");mr.space=200;class Yu{constructor(e,t,n,r){this.nodePubkey=void 0,this.authorizedVoter=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.nodePubkey=e,this.authorizedVoter=t,this.authorizedWithdrawer=n,this.commission=r}}class Il{constructor(){}static decodeInstructionType(e){this.checkProgramId(e.programId);const n=R("instruction").decode(e.data);let r;for(const[s,i]of Object.entries($e))if(i.index==n){r=s;break}if(!r)throw new Error("Instruction type incorrect; not a VoteInstruction");return r}static decodeInitializeAccount(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,4);const{voteInit:t}=j($e.InitializeAccount,e.data);return{votePubkey:e.keys[0].pubkey,nodePubkey:e.keys[3].pubkey,voteInit:new Yu(new I(t.nodePubkey),new I(t.authorizedVoter),new I(t.authorizedWithdrawer),t.commission)}}static decodeAuthorize(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{newAuthorized:t,voteAuthorizationType:n}=j($e.Authorize,e.data);return{votePubkey:e.keys[0].pubkey,authorizedPubkey:e.keys[2].pubkey,newAuthorizedPubkey:new I(t),voteAuthorizationType:{index:n}}}static decodeAuthorizeWithSeed(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:t,currentAuthorityDerivedKeySeed:n,newAuthorized:r,voteAuthorizationType:s}}=j($e.AuthorizeWithSeed,e.data);return{currentAuthorityDerivedKeyBasePubkey:e.keys[2].pubkey,currentAuthorityDerivedKeyOwnerPubkey:new I(t),currentAuthorityDerivedKeySeed:n,newAuthorizedPubkey:new I(r),voteAuthorizationType:{index:s},votePubkey:e.keys[0].pubkey}}static decodeWithdraw(e){this.checkProgramId(e.programId),this.checkKeyLength(e.keys,3);const{lamports:t}=j($e.Withdraw,e.data);return{votePubkey:e.keys[0].pubkey,authorizedWithdrawerPubkey:e.keys[2].pubkey,lamports:t,toPubkey:e.keys[1].pubkey}}static checkProgramId(e){if(!e.equals(Jt.programId))throw new Error("invalid instruction; programId is not VoteProgram")}static checkKeyLength(e,t){if(e.length<t)throw new Error(`invalid instruction; found ${e.length} keys, expected at least ${t}`)}}const $e=Object.freeze({InitializeAccount:{index:0,layout:B([R("instruction"),oc()])},Authorize:{index:1,layout:B([R("instruction"),W("newAuthorized"),R("voteAuthorizationType")])},Withdraw:{index:3,layout:B([R("instruction"),Pe("lamports")])},UpdateValidatorIdentity:{index:4,layout:B([R("instruction")])},AuthorizeWithSeed:{index:10,layout:B([R("instruction"),ic()])}}),Al=Object.freeze({Voter:{index:0},Withdrawer:{index:1}});class Jt{constructor(){}static initializeAccount(e){const{votePubkey:t,nodePubkey:n,voteInit:r}=e,s=$e.InitializeAccount,i=D(s,{voteInit:{nodePubkey:K(r.nodePubkey.toBuffer()),authorizedVoter:K(r.authorizedVoter.toBuffer()),authorizedWithdrawer:K(r.authorizedWithdrawer.toBuffer()),commission:r.commission}}),a={keys:[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:Ht,isSigner:!1,isWritable:!1},{pubkey:et,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}],programId:this.programId,data:i};return new ee(a)}static createAccount(e){const t=new G;return t.add(ye.createAccount({fromPubkey:e.fromPubkey,newAccountPubkey:e.votePubkey,lamports:e.lamports,space:this.space,programId:this.programId})),t.add(this.initializeAccount({votePubkey:e.votePubkey,nodePubkey:e.voteInit.nodePubkey,voteInit:e.voteInit}))}static authorize(e){const{votePubkey:t,authorizedPubkey:n,newAuthorizedPubkey:r,voteAuthorizationType:s}=e,i=$e.Authorize,a=D(i,{newAuthorized:K(r.toBuffer()),voteAuthorizationType:s.index}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:et,isSigner:!1,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return new G().add({keys:c,programId:this.programId,data:a})}static authorizeWithSeed(e){const{currentAuthorityDerivedKeyBasePubkey:t,currentAuthorityDerivedKeyOwnerPubkey:n,currentAuthorityDerivedKeySeed:r,newAuthorizedPubkey:s,voteAuthorizationType:i,votePubkey:a}=e,c=$e.AuthorizeWithSeed,l=D(c,{voteAuthorizeWithSeedArgs:{currentAuthorityDerivedKeyOwnerPubkey:K(n.toBuffer()),currentAuthorityDerivedKeySeed:r,newAuthorized:K(s.toBuffer()),voteAuthorizationType:i.index}}),u=[{pubkey:a,isSigner:!1,isWritable:!0},{pubkey:et,isSigner:!1,isWritable:!1},{pubkey:t,isSigner:!0,isWritable:!1}];return new G().add({keys:u,programId:this.programId,data:l})}static withdraw(e){const{votePubkey:t,authorizedWithdrawerPubkey:n,lamports:r,toPubkey:s}=e,i=$e.Withdraw,a=D(i,{lamports:r}),c=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:s,isSigner:!1,isWritable:!0},{pubkey:n,isSigner:!0,isWritable:!1}];return new G().add({keys:c,programId:this.programId,data:a})}static safeWithdraw(e,t,n){if(e.lamports>t-n)throw new Error("Withdraw will leave vote account with insufficient funds.");return Jt.withdraw(e)}static updateValidatorIdentity(e){const{votePubkey:t,authorizedWithdrawerPubkey:n,nodePubkey:r}=e,s=$e.UpdateValidatorIdentity,i=D(s),a=[{pubkey:t,isSigner:!1,isWritable:!0},{pubkey:r,isSigner:!0,isWritable:!1},{pubkey:n,isSigner:!0,isWritable:!1}];return new G().add({keys:a,programId:this.programId,data:i})}}Jt.programId=new I("Vote111111111111111111111111111111111111111");Jt.space=3762;const Ju=new I("Va1idator1nfo111111111111111111111111111111"),Xu=g({name:k(),website:L(k()),details:L(k()),iconUrl:L(k()),keybaseUsername:L(k())});class vo{constructor(e,t){this.key=void 0,this.info=void 0,this.key=e,this.info=t}static fromConfigData(e){let t=[...e];if(xe(t)!==2)return null;const r=[];for(let s=0;s<2;s++){const i=new I(Re(t,0,rt)),a=He(t)===1;r.push({publicKey:i,isSigner:a})}if(r[0].publicKey.equals(Ju)&&r[1].isSigner){const s=bt().decode(T.Buffer.from(t)),i=JSON.parse(s);return Js(i,Xu),new vo(r[1].publicKey,i)}return null}}const _l=new I("Vote111111111111111111111111111111111111111"),Zu=B([W("nodePubkey"),W("authorizedWithdrawer"),M("commission"),de(),ge(B([de("slot"),R("confirmationCount")]),dt(R(),-8),"votes"),M("rootSlotValid"),de("rootSlot"),de(),ge(B([de("epoch"),W("authorizedVoter")]),dt(R(),-8),"authorizedVoters"),B([ge(B([W("authorizedPubkey"),de("epochOfLastAuthorizedSwitch"),de("targetEpoch")]),32,"buf"),de("idx"),M("isEmpty")],"priorVoters"),de(),ge(B([de("epoch"),de("credits"),de("prevCredits")]),dt(R(),-8),"epochCredits"),B([de("slot"),de("timestamp")],"lastTimestamp")]);class Po{constructor(e){this.nodePubkey=void 0,this.authorizedWithdrawer=void 0,this.commission=void 0,this.rootSlot=void 0,this.votes=void 0,this.authorizedVoters=void 0,this.priorVoters=void 0,this.epochCredits=void 0,this.lastTimestamp=void 0,this.nodePubkey=e.nodePubkey,this.authorizedWithdrawer=e.authorizedWithdrawer,this.commission=e.commission,this.rootSlot=e.rootSlot,this.votes=e.votes,this.authorizedVoters=e.authorizedVoters,this.priorVoters=e.priorVoters,this.epochCredits=e.epochCredits,this.lastTimestamp=e.lastTimestamp}static fromAccountData(e){const n=Zu.decode(K(e),4);let r=n.rootSlot;return n.rootSlotValid||(r=null),new Po({nodePubkey:new I(n.nodePubkey),authorizedWithdrawer:new I(n.authorizedWithdrawer),commission:n.commission,votes:n.votes,rootSlot:r,authorizedVoters:n.authorizedVoters.map(Qu),priorVoters:el(n.priorVoters),epochCredits:n.epochCredits,lastTimestamp:n.lastTimestamp})}}function Qu({authorizedVoter:o,epoch:e}){return{epoch:e,authorizedVoter:new I(o)}}function us({authorizedPubkey:o,epochOfLastAuthorizedSwitch:e,targetEpoch:t}){return{authorizedPubkey:new I(o),epochOfLastAuthorizedSwitch:e,targetEpoch:t}}function el({buf:o,idx:e,isEmpty:t}){return t?[]:[...o.slice(e+1).map(us),...o.slice(0,e).map(us)]}const ls={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function El(o,e){const t=e===!1?"http":"https";if(!o)return ls[t].devnet;const n=ls[t][o];if(!n)throw new Error(`Unknown ${t} cluster: ${o}`);return n}async function xl(o,e,t,n){let r,s;t&&Object.prototype.hasOwnProperty.call(t,"lastValidBlockHeight")||t&&Object.prototype.hasOwnProperty.call(t,"nonceValue")?(r=t,s=n):s=t;const i=s&&{skipPreflight:s.skipPreflight,preflightCommitment:s.preflightCommitment||s.commitment,minContextSlot:s.minContextSlot},a=await o.sendRawTransaction(e,i),c=s&&s.commitment,u=(await(r?o.confirmTransaction(r,c):o.confirmTransaction(a,c))).value;if(u.err)throw a!=null?new fn({action:i!=null&&i.skipPreflight?"send":"simulate",signature:a,transactionMessage:`Status: (${JSON.stringify(u)})`}):new Error(`Raw transaction ${a} failed (${JSON.stringify(u)})`);return a}const Rl=1e9;export{il as Account,Zr as AddressLookupTableAccount,ml as AddressLookupTableInstruction,xo as AddressLookupTableProgram,Gu as Authorized,xc as BLOCKHASH_CACHE_TIMEOUT_MS,al as BPF_LOADER_DEPRECATED_PROGRAM_ID,yl as BPF_LOADER_PROGRAM_ID,gl as BpfLoader,nt as COMPUTE_BUDGET_INSTRUCTION_LAYOUTS,kl as ComputeBudgetInstruction,Ro as ComputeBudgetProgram,bl as Connection,br as Ed25519Program,ol as Enum,kc as EpochSchedule,dc as FeeCalculatorLayout,Dt as Keypair,Rl as LAMPORTS_PER_SOL,ct as LOOKUP_TABLE_INSTRUCTION_LAYOUTS,Pt as Loader,_n as Lockup,ec as MAX_SEED_LENGTH,Ge as Message,hn as MessageAccountKeys,Bt as MessageV0,Gr as NONCE_ACCOUNT_LENGTH,fr as NonceAccount,mt as PACKET_DATA_SIZE,rt as PUBLIC_KEY_LENGTH,I as PublicKey,dn as SIGNATURE_LENGTH_IN_BYTES,nn as SOLANA_SCHEMA,ju as STAKE_CONFIG_ID,he as STAKE_INSTRUCTION_LAYOUTS,te as SYSTEM_INSTRUCTION_LAYOUTS,et as SYSVAR_CLOCK_PUBKEY,cl as SYSVAR_EPOCH_SCHEDULE_PUBKEY,ul as SYSVAR_INSTRUCTIONS_PUBKEY,Nn as SYSVAR_RECENT_BLOCKHASHES_PUBKEY,Ht as SYSVAR_RENT_PUBKEY,ll as SYSVAR_REWARDS_PUBKEY,dl as SYSVAR_SLOT_HASHES_PUBKEY,hl as SYSVAR_SLOT_HISTORY_PUBKEY,Kn as SYSVAR_STAKE_HISTORY_PUBKEY,Mt as Secp256k1Program,fn as SendTransactionError,v as SolanaJSONRPCError,fl as SolanaJSONRPCErrorCode,Sl as StakeAuthorizationLayout,wl as StakeInstruction,mr as StakeProgram,so as Struct,pl as SystemInstruction,ye as SystemProgram,G as Transaction,io as TransactionExpiredBlockheightExceededError,Ft as TransactionExpiredNonceInvalidError,ao as TransactionExpiredTimeoutError,ee as TransactionInstruction,ho as TransactionMessage,at as TransactionStatus,Ju as VALIDATOR_INFO_KEY,hr as VERSION_PREFIX_MASK,_l as VOTE_PROGRAM_ID,vo as ValidatorInfo,lo as VersionedMessage,fo as VersionedTransaction,Po as VoteAccount,Al as VoteAuthorizationLayout,Yu as VoteInit,Il as VoteInstruction,Jt as VoteProgram,El as clusterApiUrl,xl as sendAndConfirmRawTransaction,jr as sendAndConfirmTransaction};
